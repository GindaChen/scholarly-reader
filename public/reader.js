/**
 * Scholarly Reader — Client-Side Interactivity
 *
 * This is a THIN client. It does NOT compile Markdown or render LaTeX.
 * All document content is pre-generated by agents as HTML.
 *
 * Responsibilities:
 *   1. Load pre-generated HTML from server API
 *   2. Extract metadata (title, variables, references) from data attributes
 *   3. Populate left panel (variables) and right panel (references)
 *   4. Handle variable hover highlighting across doc + sidebar
 *   5. Handle TOC generation from headings
 *   6. Handle text selection toolbar + notes persistence
 *   7. Handle panel collapse/expand + right panel resize
 */

(function () {
    'use strict';

    const $ = (s) => document.querySelector(s);
    const $$ = (s) => document.querySelectorAll(s);

    // ═══════════════════════════════════════════════
    //  State
    // ═══════════════════════════════════════════════
    const state = {
        docId: null,
        filename: null,
        variables: {},   // { name: { desc, color } }
        references: {},  // { "1": { title, url, quote } }
        annotations: [],
        activeRef: null,
        pendingNoteText: null,
        pendingNoteRange: null,
        pendingNoteSource: 'human',
        userEdits: {},   // persisted: { varDescs: { name: desc }, refNotes: { num: note } }
        pinnedVars: new Set(), // currently pinned variable names
        highlights: [],  // persisted user highlights
        collapses: [],   // persisted text collapses
        historyTree: {
            rootId: 'root',
            nodes: {},
            headId: 'root'
        },
    };

    const article = $('#article');
    const tocMenu = $('#toc-menu');
    const selToolbar = $('#selection-toolbar');
    const panelLeft = $('#panel-left');
    const panelRefs = $('#panel-refs');
    const panelNotes = $('#panel-notes');

    // ═══════════════════════════════════════════════
    //  Init
    // ═══════════════════════════════════════════════
    async function init() {
        // Detect Electron environment for desktop-specific CSS/layout
        if (navigator.userAgent.toLowerCase().includes('electron')) {
            document.body.classList.add('is-electron');
        }

        const params = new URLSearchParams(window.location.search);
        state.docId = params.get('doc') || null;

        if (!state.docId) {
            const docs = await fetchJSON('/api/docs');
            if (docs.length > 0) {
                state.docId = docs[0].id;
            } else {
                showError('No documents found. Add folders with metadata.yaml to the docs/ directory.');
                return;
            }
        }

        // For backward compat, keep state.filename as an alias
        state.filename = state.docId;

        // Load document HTML + annotations
        const [docData, annotations] = await Promise.all([
            fetchJSON(`/api/doc/${state.docId}`),
            fetchJSON(`/api/annotations/${state.docId}`).catch(() => []),
        ]);

        state.annotations = annotations || [];

        // Insert pre-generated HTML
        article.innerHTML = docData.content;

        // Remove loading="lazy" — local images load instantly and lazy
        // causes layout shift that breaks TOC navigation on first click
        article.querySelectorAll('img[loading="lazy"]').forEach(img => img.removeAttribute('loading'));

        // Extract metadata from the HTML content
        extractVariables();
        extractReferences();
        state.mainReferences = { ...state.references }; // permanent copy, never overwritten
        setupMathToggles();
        fixOrphanedLatex();
        fixMboxCitations();

        // Set document title
        const docTitle = docData.title || article.querySelector('h1')?.textContent || state.docId;
        $('#doc-title').textContent = docTitle;
        document.title = `${docTitle} — Scholarly Reader`;

        // Build UI
        buildVarsPanel();
        buildRefsPanel();
        buildTOC();
        renderAnnotationsList();

        // Setup interactivity
        setupLeftPanel();
        setupRightPanel();
        setupResizeHandle();
        setupTOCDropdown();
        setupVarHovers();
        setupRefBadgeClicks();
        setupSelectionToolbar();
        setupSettings();
        setupContextMenu();
        setupDocPicker();
        setupPaperLinks(docData);
        setupTypography();
        setupReadingProgress();
        setupKeyboardShortcuts();
        setupFocusMode();
        setupAnnotations();
        setupAnnotationClick();
        setupHistoryTree();
        setupEraserMode();
        setupSplitViews();
        setupSplitDragReorder();
    }

    // ═══════════════════════════════════════════════
    //  Paper Links Dropdown (arXiv, PDF)
    // ═══════════════════════════════════════════════

    function setupPaperLinks(docData) {
        const dropdown = $('#paper-links-dropdown');
        const trigger = $('#paper-links-trigger');
        const menu = $('#paper-links-menu');
        if (!dropdown || !trigger || !menu) return;

        const links = [];
        if (docData.url) {
            links.push({
                label: 'arXiv Page',
                url: docData.url,
                icon: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 016.5 17H20M4 19.5A2.5 2.5 0 016.5 17H20M4 19.5V5a2 2 0 012-2h14v14H6.5"/></svg>`,
            });
        }
        if (docData.pdf) {
            links.push({
                label: 'Download PDF',
                url: docData.pdf,
                icon: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><polyline points="9 15 12 18 15 15"/></svg>`,
            });
        }

        if (links.length === 0) return;

        dropdown.style.display = '';
        menu.innerHTML = links.map(l =>
            `<a class="paper-link-item" href="${esc(l.url)}" target="_blank" rel="noopener">${l.icon}<span>${esc(l.label)}</span></a>`
        ).join('');

        trigger.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('open');
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('#paper-links-dropdown')) {
                dropdown.classList.remove('open');
            }
        });
    }

    // ═══════════════════════════════════════════════
    //  Settings & Theme System
    // ═══════════════════════════════════════════════

    function setupSettings() {
        const THEME_KEY = 'scholarly-reader-theme';
        const dropdown = $('#settings-dropdown');
        const toggle = $('#settings-toggle');

        // Restore saved theme
        const saved = localStorage.getItem(THEME_KEY) || 'midnight';
        applyTheme(saved);

        // Toggle dropdown
        toggle.addEventListener('click', () => {
            dropdown.classList.toggle('open');
        });

        // Close on outside click, but keep open when clicking inside
        document.addEventListener('click', (e) => {
            if (!dropdown.contains(e.target) && !toggle.contains(e.target)) {
                dropdown.classList.remove('open');
            }
        });

        // Theme buttons
        $$('.theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const theme = btn.dataset.theme;
                applyTheme(theme);
                try { localStorage.setItem(THEME_KEY, theme); } catch { }
            });
        });

        function applyTheme(theme) {
            if (theme === 'midnight') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', theme);
            }
            $$('.theme-btn').forEach(b => {
                b.classList.toggle('active', b.dataset.theme === theme);
            });
        }

        // Figure max-width slider
        const FIG_KEY = 'scholarly-reader-fig-width';
        const figSlider = $('#fig-width-slider');
        const figLabel = $('#fig-width-label');
        if (figSlider && figLabel) {
            const savedW = localStorage.getItem(FIG_KEY) || '400';
            applyFigWidth(savedW);
            figSlider.value = savedW;

            figSlider.addEventListener('input', () => {
                applyFigWidth(figSlider.value);
                try { localStorage.setItem(FIG_KEY, figSlider.value); } catch { }
            });
        }

        function applyFigWidth(px) {
            document.documentElement.style.setProperty('--fig-max-w', px + 'px');
            if (figLabel) figLabel.textContent = `Max ${px}px`;
        }

    }

    // ═══════════════════════════════════════════════
    //  Document Picker
    // ═══════════════════════════════════════════════

    function setupDocPicker() {
        const picker = $('#doc-picker');
        const trigger = $('#doc-picker-trigger');
        const menu = $('#doc-picker-menu');

        let cachedDocs = []; // cache for re-rendering after mutations

        async function renderMenu() {
            try {
                cachedDocs = await fetchJSON('/api/docs');
            } catch (e) {
                console.error('Failed to load docs', e);
                return;
            }
            buildMenuHTML();
        }

        function buildMenuHTML() {
            menu.innerHTML = cachedDocs.map(d => {
                const isActive = d.id === state.docId;
                const badge = d.conference ? `<span class="doc-item-badge">${d.conference}</span>` : '';
                const authorLine = d.authors ? `<span class="doc-item-authors">${esc(d.authors).substring(0, 50)}</span>` : '';
                const pinIcon = d.pinned
                    ? `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M16 2l-4 4-5-3-3 3 4 5-4 4v2h2l4-4 5 4 3-3-3-5 4-4V2h-2z"/></svg>`
                    : `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 2l-4 4-5-3-3 3 4 5-4 4v2h2l4-4 5 4 3-3-3-5 4-4V2h-2z"/></svg>`;

                return `<div class="doc-item${isActive ? ' active' : ''}${d.pinned ? ' pinned' : ''}" data-doc-id="${esc(d.id)}">
                    <div class="doc-item-main">
                        <span class="doc-item-name" title="Double-click to rename">${esc(d.short_title || d.title)}</span>
                        ${badge}
                        <button class="doc-item-action doc-item-edit" data-doc-id="${esc(d.id)}" title="Rename">
                            <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                        </button>
                        <button class="doc-item-action doc-item-pin${d.pinned ? ' active' : ''}" data-doc-id="${esc(d.id)}" title="${d.pinned ? 'Unpin' : 'Pin to top'}">
                            ${pinIcon}
                        </button>
                    </div>
                    <div class="doc-item-meta">
                        ${authorLine}
                    </div>
                    <div class="doc-item-path">docs/${esc(d.id)}/</div>
                </div>`;
            }).join('');
            attachMenuListeners();
        }

        function attachMenuListeners() {
            // Navigate on click (but not on action buttons or inputs)
            menu.querySelectorAll('.doc-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.closest('.doc-item-action') || e.target.closest('.doc-item-rename-input')) return;
                    const docId = item.dataset.docId;
                    if (docId && docId !== state.docId) {
                        window.location.search = `?doc=${encodeURIComponent(docId)}`;
                    }
                    picker.classList.remove('open');
                });
            });

            // Pin/unpin
            menu.querySelectorAll('.doc-item-pin').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const docId = btn.dataset.docId;
                    const doc = cachedDocs.find(d => d.id === docId);
                    if (!doc) return;
                    const newPinned = !doc.pinned;
                    try {
                        await fetch(`/api/doc-metadata/${encodeURIComponent(docId)}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ pinned: newPinned }),
                        });
                        doc.pinned = newPinned;
                        // Re-sort: pinned first, then year desc, then title
                        cachedDocs.sort((a, b) => (b.pinned ? 1 : 0) - (a.pinned ? 1 : 0) || (b.year || 0) - (a.year || 0) || (a.title || '').localeCompare(b.title || ''));
                        buildMenuHTML();
                    } catch (err) {
                        console.error('Failed to update pin', err);
                    }
                });
            });

            // Edit/rename
            menu.querySelectorAll('.doc-item-edit').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const docId = btn.dataset.docId;
                    startRename(docId);
                });
            });

            // Double-click on name to rename
            menu.querySelectorAll('.doc-item-name').forEach(nameEl => {
                nameEl.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    const docId = nameEl.closest('.doc-item').dataset.docId;
                    startRename(docId);
                });
            });
        }

        function startRename(docId) {
            const doc = cachedDocs.find(d => d.id === docId);
            if (!doc) return;
            const item = menu.querySelector(`.doc-item[data-doc-id="${CSS.escape(docId)}"]`);
            const nameEl = item?.querySelector('.doc-item-name');
            if (!nameEl) return;

            const currentName = doc.short_title || doc.title;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'doc-item-rename-input';
            input.value = currentName;
            nameEl.replaceWith(input);
            input.focus();
            input.select();

            const commitRename = async () => {
                const newName = input.value.trim();
                if (!newName || newName === currentName) {
                    buildMenuHTML(); // revert
                    return;
                }
                try {
                    await fetch(`/api/doc-metadata/${encodeURIComponent(docId)}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ short_title: newName }),
                    });
                    doc.short_title = newName;
                    // If this is the active doc, update the title bar too
                    if (docId === state.docId) {
                        $('#doc-title').textContent = newName;
                    }
                } catch (err) {
                    console.error('Failed to rename', err);
                }
                buildMenuHTML();
            };

            input.addEventListener('blur', commitRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
                if (e.key === 'Escape') { e.preventDefault(); buildMenuHTML(); }
            });
        }

        trigger.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (picker.classList.contains('open')) {
                picker.classList.remove('open');
                return;
            }
            await renderMenu();
            picker.classList.add('open');
        });

        // Close on any click outside the picker
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#doc-picker')) {
                picker.classList.remove('open');
            }
        });
    }

    // ═══════════════════════════════════════════════
    //  Typography Controls
    // ═══════════════════════════════════════════════

    function setupTypography() {
        const FONT_KEY = 'scholarly-reader-font';
        const SIZE_KEY = 'scholarly-reader-size';

        const savedFont = localStorage.getItem(FONT_KEY) || 'serif';
        const savedSize = localStorage.getItem(SIZE_KEY) || 'md';
        applyFont(savedFont);
        applySize(savedSize);

        $$('.typo-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const font = btn.dataset.font;
                applyFont(font);
                try { localStorage.setItem(FONT_KEY, font); } catch { }
            });
        });

        $$('.typo-size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const size = btn.dataset.size;
                applySize(size);
                try { localStorage.setItem(SIZE_KEY, size); } catch { }
            });
        });

        function applyFont(font) {
            document.documentElement.setAttribute('data-font', font);
            $$('.typo-btn').forEach(b => b.classList.toggle('active', b.dataset.font === font));
        }
        function applySize(size) {
            document.documentElement.setAttribute('data-size', size);
            $$('.typo-size-btn').forEach(b => b.classList.toggle('active', b.dataset.size === size));
        }
    }

    // ═══════════════════════════════════════════════
    //  Reading Progress Bar
    // ═══════════════════════════════════════════════

    function setupReadingProgress() {
        const bar = $('#reading-progress');
        const update = () => {
            const scrollable = document.documentElement.scrollHeight - window.innerHeight;
            if (scrollable <= 0) { bar.style.width = '0'; return; }
            const pct = Math.min(100, (window.scrollY / scrollable) * 100);
            bar.style.width = pct + '%';
        };
        window.addEventListener('scroll', update, { passive: true });
        update();
    }

    // ═══════════════════════════════════════════════
    //  Keyboard Shortcuts
    // ═══════════════════════════════════════════════

    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Don't fire in text inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // ? — show shortcuts help
            if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                toggleShortcutsHelp();
                return;
            }

            // f — focus mode
            if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                document.body.classList.toggle('focus-mode');
                try { localStorage.setItem('scholarly-reader-focus', document.body.classList.contains('focus-mode')); } catch { }
                return;
            }

            // e — eraser mode
            if (e.key === 'e' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                $('#eraser-btn')?.click();
                return;
            }

            // t — focus TOC
            if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                $('#toc-trigger')?.click();
                return;
            }

            // Escape — close any open overlay/menu
            if (e.key === 'Escape') {
                // Close shortcuts help
                const help = $('#shortcuts-help');
                if (help) { help.remove(); return; }
                // Close settings
                $('#settings-dropdown')?.classList.remove('open');
                // Close doc picker
                $('#doc-picker')?.classList.remove('open');
                // Close TOC
                $('#toc-dropdown')?.classList.remove('open');
                // Close edit overlay
                $('#edit-overlay')?.classList.remove('visible');
                // Close history panel
                $('#panel-history')?.classList.add('collapsed');
                $('#history-toggle')?.classList.remove('active');
                return;
            }

            // 1/2/3 — toggle panels
            if (e.key === '1' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault(); $('#vars-toggle')?.click(); return;
            }
            if (e.key === '2' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault(); $('#refs-toggle')?.click(); return;
            }
            if (e.key === '3' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault(); $('#notes-toggle')?.click(); return;
            }
            // 4 - toggle history panel
            if (e.key === '4' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault(); $('#history-toggle')?.click(); return;
            }
        });

        function toggleShortcutsHelp() {
            let help = $('#shortcuts-help');
            if (help) { help.remove(); return; }
            help = document.createElement('div');
            help.id = 'shortcuts-help';
            help.className = 'edit-overlay visible';
            help.innerHTML = `
                <div class="edit-modal" style="width:380px">
                    <h4>⌨️ Keyboard Shortcuts</h4>
                    <div style="margin-top:12px;font-family:'Inter',sans-serif;font-size:13px;color:var(--text-secondary);line-height:2.2">
                        <div style="display:flex;justify-content:space-between"><span>Undo</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">⌘Z</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>Redo</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">⌘⇧Z</kbd></div>
                        <div style="border-top:1px solid var(--border);margin:4px 0"></div>
                        <div style="display:flex;justify-content:space-between"><span>Focus Mode</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">F</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>Eraser Mode</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">E</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>Table of Contents</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">T</kbd></div>
                        <div style="border-top:1px solid var(--border);margin:4px 0"></div>
                        <div style="display:flex;justify-content:space-between"><span>Variables Panel</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">⌘ 1</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>References Panel</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">⌘ 2</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>Notes Panel</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">⌘ 3</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>History Panel</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">⌘ 4</kbd></div>
                        <div style="border-top:1px solid var(--border);margin:4px 0"></div>
                        <div style="display:flex;justify-content:space-between"><span>Close / Dismiss</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">Esc</kbd></div>
                        <div style="display:flex;justify-content:space-between"><span>This Help</span><kbd style="padding:2px 8px;background:var(--surface-2);border-radius:4px;font-size:11px;font-family:'JetBrains Mono',monospace">?</kbd></div>
                    </div>
                    <div class="edit-actions">
                        <button class="edit-btn-save" onclick="this.closest('.edit-overlay').remove()">Got it</button>
                    </div>
                </div>`;
            help.addEventListener('click', (e) => { if (e.target === help) help.remove(); });
            document.body.appendChild(help);
        }
    }

    // ═══════════════════════════════════════════════
    //  Focus Mode
    // ═══════════════════════════════════════════════

    function setupFocusMode() {
        // Restore saved state
        if (localStorage.getItem('scholarly-reader-focus') === 'true') {
            document.body.classList.add('focus-mode');
        }
        // Button in settings
        const btn = $('#focus-mode-toggle');
        if (btn) {
            btn.addEventListener('click', () => {
                document.body.classList.toggle('focus-mode');
                try { localStorage.setItem('scholarly-reader-focus', document.body.classList.contains('focus-mode')); } catch { }
                // Close settings dropdown
                $('#settings-dropdown')?.classList.remove('open');
            });
        }
    }

    // ═══════════════════════════════════════════════
    //  Context Menu + Inline Editing
    // ═══════════════════════════════════════════════

    function setupContextMenu() {
        const EDITS_KEY = () => `scholarly-reader-edits-${state.docId}`;
        const ctxMenu = $('#ctx-menu');
        const overlay = $('#edit-overlay');
        const editTitle = $('#edit-title');
        const editLabel = $('#edit-label');
        const editArea = $('#edit-textarea');
        let editCallback = null;

        // Load persisted user edits
        try {
            const saved = JSON.parse(localStorage.getItem(EDITS_KEY()));
            if (saved) state.userEdits = saved;
        } catch { }
        if (!state.userEdits.varDescs) state.userEdits.varDescs = {};
        if (!state.userEdits.refNotes) state.userEdits.refNotes = {};

        // Apply persisted variable description overrides
        Object.entries(state.userEdits.varDescs).forEach(([name, desc]) => {
            if (state.variables[name]) state.variables[name].desc = desc;
        });
        // Rebuild panels with user edits applied
        buildVarsPanel();
        if (state.activeRef) showRefDetail(state.activeRef);

        function saveEdits() {
            try { localStorage.setItem(EDITS_KEY(), JSON.stringify(state.userEdits)); } catch { }
        }

        // ── Right-click handler ──
        article.addEventListener('contextmenu', (e) => {
            const varEl = e.target.closest('.var[data-var]');
            const refEl = e.target.closest('.ref-badge[data-ref]');
            if (!varEl && !refEl) return;
            e.preventDefault();

            let items = '';
            if (varEl) {
                const name = varEl.dataset.var;
                items = `
                    <button class="ctx-item" data-action="edit-var" data-name="${esc(name)}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                            <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                        Edit Description
                    </button>`;
            }
            if (refEl) {
                const num = refEl.dataset.ref;
                const hasNote = state.userEdits.refNotes[num];
                items += `
                    <button class="ctx-item" data-action="edit-ref" data-num="${esc(num)}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/>
                        </svg>
                        ${hasNote ? 'Edit Note' : 'Add Note'}
                    </button>`;
            }

            ctxMenu.innerHTML = items;
            // Position menu
            const x = Math.min(e.clientX, window.innerWidth - 200);
            const y = Math.min(e.clientY, window.innerHeight - 120);
            ctxMenu.style.left = x + 'px';
            ctxMenu.style.top = y + 'px';
            ctxMenu.classList.add('visible');
        });

        // ── Handle menu item clicks ──
        ctxMenu.addEventListener('click', (e) => {
            const btn = e.target.closest('.ctx-item');
            if (!btn) return;
            ctxMenu.classList.remove('visible');

            const action = btn.dataset.action;
            if (action === 'edit-var') {
                const name = btn.dataset.name;
                const v = state.variables[name];
                openEditModal(
                    `Edit Variable: ${name}`,
                    `Update the description for this variable.`,
                    v?.desc || '',
                    (newDesc) => {
                        state.variables[name].desc = newDesc;
                        state.userEdits.varDescs[name] = newDesc;
                        saveEdits();
                        // Update all data-desc attributes in doc
                        article.querySelectorAll(`.var[data-var="${CSS.escape(name)}"]`).forEach(el => {
                            el.dataset.desc = newDesc;
                        });
                        buildVarsPanel();
                    }
                );
            } else if (action === 'edit-ref') {
                const num = btn.dataset.num;
                const ref = state.references[num];
                openEditModal(
                    `Note on: [${num}] ${ref?.title || ''}`,
                    `Add your own note to this reference. It will appear in cyan below the quote.`,
                    state.userEdits.refNotes[num] || '',
                    (newNote) => {
                        if (newNote.trim()) {
                            state.userEdits.refNotes[num] = newNote;
                        } else {
                            delete state.userEdits.refNotes[num];
                        }
                        saveEdits();
                        // Re-render ref detail if it's the active one
                        showRefDetail(num);
                        // Open refs panel if closed
                        if (panelRefs.classList.contains('collapsed')) {
                            panelRefs.classList.remove('collapsed');
                            $('#refs-toggle').classList.add('active');
                        }
                    }
                );
            }
        });

        // ── Close context menu on outside click ──
        document.addEventListener('click', () => ctxMenu.classList.remove('visible'));
        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('.var[data-var]') && !e.target.closest('.ref-badge[data-ref]')) {
                ctxMenu.classList.remove('visible');
            }
        });

        // ── Edit modal ──
        function openEditModal(title, label, value, onSave) {
            editTitle.textContent = title;
            editLabel.textContent = label;
            editArea.value = value;
            editCallback = onSave;
            overlay.classList.add('visible');
            setTimeout(() => editArea.focus(), 50);
        }

        function closeEditModal() {
            overlay.classList.remove('visible');
            editCallback = null;
        }

        $('#edit-cancel').addEventListener('click', closeEditModal);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) closeEditModal();
        });
        $('#edit-save').addEventListener('click', () => {
            if (editCallback) editCallback(editArea.value);
            closeEditModal();
        });
        // Ctrl+Enter to save
        editArea.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                if (editCallback) editCallback(editArea.value);
                closeEditModal();
            }
        });
    }

    // ═══════════════════════════════════════════════
    //  Extract Metadata from Agent-Generated HTML
    // ═══════════════════════════════════════════════

    /**
     * Scan for <span class="var" data-var="name" data-desc="..." style="--var-color: #hex">
     * and build the variable registry.
     */
    function extractVariables() {
        // Build ordered array of all headings for chapter lookup
        const headings = Array.from(article.querySelectorAll('h1, h2, h3'));

        // Skip variables inside the legend (they're a summary, not first occurrences)
        const allVarEls = Array.from(article.querySelectorAll('.var[data-var]'))
            .filter(el => !el.closest('.variable-legend'));
        allVarEls.forEach((el, index) => {
            const name = el.dataset.var;
            if (!state.variables[name]) {
                // Find the nearest preceding heading
                let chapter = '(Preamble)';
                for (let i = headings.length - 1; i >= 0; i--) {
                    if (headings[i].compareDocumentPosition(el) & Node.DOCUMENT_POSITION_FOLLOWING) {
                        chapter = headings[i].textContent.trim();
                        break;
                    }
                }

                state.variables[name] = {
                    desc: el.dataset.desc || '',
                    color: getComputedStyle(el).getPropertyValue('--var-color').trim() || '#f0a050',
                    firstIndex: index,
                    chapter: chapter,
                };
            }
        });

        // Collapse variable legend into a toggleable dropdown
        const legend = article.querySelector('.variable-legend');
        if (legend) {
            legend.style.display = 'none';
            const splitControls = $('#split-controls');
            if (splitControls && !$('#btn-var-legend')) {
                const btn = document.createElement('button');
                btn.className = 'split-btn';
                btn.id = 'btn-var-legend';
                btn.title = 'Toggle variable legend';
                btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7h6M4 17h6M14 4l-4 16M20 7l-4 10"/></svg> Variables`;
                btn.addEventListener('click', () => {
                    const visible = legend.style.display !== 'none';
                    legend.style.display = visible ? 'none' : '';
                    btn.classList.toggle('active', !visible);
                });
                splitControls.appendChild(btn);
            }
        }
    }

    /**
     * Extract a ref map from any content element (main article or split content).
     * Returns { [num]: { num, title, url, quote, arxivId } }
     */
    function extractRefsFromEl(el) {
        const refs = {};
        // Pass 1: ref-badge data attributes
        el.querySelectorAll('.ref-badge[data-ref]').forEach(badge => {
            const num = badge.dataset.ref;
            if (!refs[num]) {
                refs[num] = {
                    num: parseInt(num) || num,
                    title: badge.dataset.title || badge.dataset.arxivId || `Reference ${num}`,
                    url: badge.dataset.url || '',
                    quote: badge.dataset.quote || '',
                    arxivId: badge.dataset.arxivId || '',
                };
            }
        });
        // Pass 2: build/enrich from bibliography <li id="ref-N">
        el.querySelectorAll('li[id^="ref-"]').forEach((li, idx) => {
            const num = li.id.replace('ref-', '');
            const text = li.textContent || '';
            const html = li.innerHTML || '';
            const arxivMatch = text.match(/arxiv[:/]+(\d{4}\.\d{4,5}(?:v\d+)?)/i);
            const linkMatch = html.match(/href="([^"]+)"/i);

            // Extract title: text between </strong> and <em> (authors in strong, venue in em)
            const afterStrong = html.replace(/<strong[^>]*>[\s\S]*?<\/strong>/i, '');
            const beforeEm = afterStrong.replace(/<em[\s\S]*$/i, '');
            const parsedTitle = beforeEm.replace(/<[^>]+>/g, '').replace(/^\s*\.?\s*/, '').trim();

            if (refs[num]) {
                // Only override title if we got something meaningful (>4 chars)
                if (parsedTitle.length > 4) refs[num].title = parsedTitle;
                if (arxivMatch && !refs[num].arxivId) refs[num].arxivId = arxivMatch[1].split('v')[0];
                if (linkMatch && !refs[num].url) refs[num].url = linkMatch[1];
            } else {
                // Create entry from bibliography even if no inline badge found
                refs[num] = {
                    num: parseInt(num) || num,
                    title: parsedTitle || `Reference ${num}`,
                    url: linkMatch ? linkMatch[1] : '',
                    quote: '',
                    arxivId: arxivMatch ? arxivMatch[1].split('v')[0] : '',
                };
            }
        });
        return refs;
    }

    /** Populate state.references from main article and rebuild the panel. */
    function extractReferences() {
        state.references = extractRefsFromEl(article);
    }

    /**
     * Switch the References panel to show a given ref map,
     * optionally highlighting and showing detail for one ref.
     * @param {object} refsMap - { [num]: ref }
     * @param {string} [activeNum] - ref number to highlight/show detail
     * @param {string} [paperTitle] - label for the panel header
     */
    function switchRefsPanel(refsMap, activeNum, paperTitle) {
        const refList = $('#ref-list');
        const detailView = $('#ref-detail-view');
        if (!refList) return;

        // Update panel header label if provided
        const panelLabel = document.querySelector('#refs-panel .panel-title, #refs-panel .panel-header span');
        if (panelLabel && paperTitle) panelLabel.textContent = paperTitle;

        refList.innerHTML = '';
        if (detailView) detailView.innerHTML = '';

        const nums = Object.keys(refsMap).sort((a, b) => (parseInt(a) || 0) - (parseInt(b) || 0));
        if (nums.length === 0) {
            refList.innerHTML = '<li class="panel-empty">No references found.</li>';
            return;
        }

        nums.forEach(num => {
            const ref = refsMap[num];
            const li = document.createElement('li');
            li.className = 'ref-list-item';
            li.dataset.ref = num;
            li.innerHTML = `<span class="ref-num">[${num}]</span> <span class="ref-title">${esc(ref.title)}</span>`;
            li.addEventListener('click', () => {
                const prev = state.references;
                state.references = refsMap;
                showRefDetail(num);
                // Open split using this refsMap's ref data (not main article's)
                openRefInSplitViewFromRef(refsMap[num], num);
                state.references = prev;
            });
            refList.appendChild(li);
        });

        if (activeNum) {
            const prev = state.references;
            state.references = refsMap; // temporary so showRefDetail finds the right ref
            showRefDetail(activeNum);
            state.references = prev;    // restore immediately after
        }
    }

    /**
     * Add click listeners to math blocks to toggle raw text view
     */
    /**
     * Fix orphaned raw LaTeX fragments between rendered KaTeX spans.
     * Scans text nodes for common LaTeX patterns and wraps them in KaTeX.
     */
    function fixOrphanedLatex() {
        if (!window.katex) return;
        const latexPattern = /(?:\[a-zA-Z]+(?:\{[^}]*\})*|[a-zA-Z_^]+\{[^}]*\}|\[()\[\]])/;
        const walker = document.createTreeWalker(article, NodeFilter.SHOW_TEXT, {
            acceptNode(node) {
                const p = node.parentElement;
                if (!p) return NodeFilter.FILTER_REJECT;
                if (p.closest('.katex, .katex-mathml, .katex-html, .math-raw, .math-inline, .math-display, code, pre, script, style')) return NodeFilter.FILTER_REJECT;
                if (p.classList.contains('ref-badge')) return NodeFilter.FILTER_REJECT;
                return latexPattern.test(node.textContent) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            }
        });
        const nodes = [];
        let n;
        while ((n = walker.nextNode())) nodes.push(n);

        nodes.forEach(node => {
            const text = node.textContent;
            // Only process if it looks like math (has backslashes or math operators)
            if (!text.match(/\[a-zA-Z]+/)) return;
            // Skip if it's just whitespace with a backslash
            if (text.trim().length < 2) return;
            try {
                const rendered = katex.renderToString(text.trim(), {
                    displayMode: false,
                    throwOnError: false,
                    trust: true,
                });
                // Only replace if KaTeX actually produced something meaningful
                if (rendered && !rendered.includes('katex-error')) {
                    const wrapper = document.createElement('span');
                    wrapper.className = 'katex-inline';
                    wrapper.innerHTML = rendered;
                    node.parentNode.replaceChild(wrapper, node);
                }
            } catch (e) { /* leave as-is */ }
        });
    }

    /**
     * Fix \mbox{[key]} citations in pre-generated HTML by converting them to ref badges.
     * Also converts bare [key] text that matches known bibliography entries.
     */
    function fixMboxCitations() {
        // Build ref key map from bibliography
        const refMap = {};
        article.querySelectorAll('li[id^="ref-"]').forEach((li, idx) => {
            const rawKey = li.id.replace('ref-', '');
            const num = String(idx + 1);
            const arxivMatch = (li.textContent || '').match(/arxiv[:/]+([0-9]{4}\.[0-9]{4,5}(?:v[0-9]+)?)/i);
            const linkMatch = (li.innerHTML || '').match(/href="([^"]+)"/i);
            const titleEl = li.querySelector('em') || li.querySelector('strong');
            const title = titleEl ? titleEl.textContent.trim() : (li.textContent.split('.')[1] || '').trim() || rawKey;
            refMap[rawKey] = { num, title, arxivId: arxivMatch ? arxivMatch[1] : '', url: linkMatch ? linkMatch[1] : '' };
        });

        // Also build map from existing ref-badge data attributes
        article.querySelectorAll('.ref-badge[data-ref]').forEach(el => {
            const key = el.dataset.ref;
            if (!refMap[key] && el.dataset.title) {
                refMap[key] = { num: key, title: el.dataset.title, arxivId: el.dataset.arxivId || '', url: el.dataset.url || '' };
            }
        });

        if (Object.keys(refMap).length === 0) return;

        // Find text nodes containing \mbox{[...]} or bare [key] patterns
        const mboxPattern = /\\mbox\{\[([^\]]+)\]\}|\[([^\]]{2,60})\]/;
        const walker = document.createTreeWalker(article, NodeFilter.SHOW_TEXT, {
            acceptNode(node) {
                const p = node.parentElement;
                if (!p) return NodeFilter.FILTER_REJECT;
                if (p.closest('.katex, .katex-mathml, .katex-html, .math-raw, code, pre, script, style, .references')) return NodeFilter.FILTER_REJECT;
                if (p.classList.contains('ref-badge')) return NodeFilter.FILTER_REJECT;
                if (p.tagName === 'SUP') return NodeFilter.FILTER_REJECT;
                return mboxPattern.test(node.textContent) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            }
        });

        const textNodes = [];
        let tn;
        while ((tn = walker.nextNode())) textNodes.push(tn);

        textNodes.forEach(node => {
            const frag = document.createDocumentFragment();
            let last = 0;
            const text = node.textContent;
            // Match \mbox{[key]} or [key]
            const pat = /\mbox\{\[([^\]]+)\]\}|\[([^\]]{2,60})\]/g;
            let m;
            while ((m = pat.exec(text)) !== null) {
                const inner = m[1] || m[2];
                const keys = inner.split(/[,;]+/).map(k => k.trim()).filter(Boolean);
                const matched = keys.filter(k => refMap[k]);
                if (matched.length === 0) continue;

                if (m.index > last) frag.appendChild(document.createTextNode(text.slice(last, m.index)));
                last = m.index + m[0].length;

                matched.forEach((key, i) => {
                    const ref = refMap[key];
                    const sup = document.createElement('sup');
                    sup.className = 'ref-badge';
                    sup.dataset.ref = ref.num;
                    sup.dataset.title = ref.title;
                    if (ref.arxivId) sup.dataset.arxivId = ref.arxivId;
                    if (ref.url) sup.dataset.url = ref.url;
                    sup.textContent = ref.num;
                    sup.style.cursor = 'pointer';
                    frag.appendChild(sup);
                });
            }
            if (last > 0) {
                if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
                node.parentNode.replaceChild(frag, node);
            }
        });
    }

    function setupMathToggles() {
        // Render all math-raw spans via KaTeX
        if (window.katex) {
            article.querySelectorAll('.math-raw').forEach(span => {
                const raw = span.textContent || '';
                const isDisplay = span.closest('.math-display') !== null;
                try {
                    const rendered = katex.renderToString(raw, {
                        displayMode: isDisplay,
                        throwOnError: false,
                        trust: true,
                    });
                    const wrapper = document.createElement('span');
                    wrapper.className = isDisplay ? 'katex-display' : 'katex-inline';
                    wrapper.innerHTML = rendered;
                    span.replaceWith(wrapper);
                } catch (e) { /* leave as-is */ }
            });
        }
    }

    // ═══════════════════════════════════════════════
    //  Variables Panel (left)
    // ═══════════════════════════════════════════════

    let varSortMode = 'chapter'; // 'chapter' | 'occurrence' | 'alpha'
    let varFilterText = '';

    function buildVarsPanel() {
        const body = $('#vars-body');
        const names = Object.keys(state.variables);
        if (names.length === 0) {
            body.innerHTML = '<p class="panel-empty">No annotated variables in this document.</p>';
            return;
        }

        // Build controls once
        let html = `
            <div class="var-controls">
                <input type="text" class="var-filter-input" id="var-filter" placeholder="Filter variables…" value="${esc(varFilterText)}" />
                <div class="var-toolbar">
                    <div class="var-sort-group">
                        <button class="var-sort-btn ${varSortMode === 'chapter' ? 'active' : ''}" data-sort="chapter" title="Group by chapter">§</button>
                        <button class="var-sort-btn ${varSortMode === 'occurrence' ? 'active' : ''}" data-sort="occurrence" title="Sort by first occurrence">1st</button>
                        <button class="var-sort-btn ${varSortMode === 'alpha' ? 'active' : ''}" data-sort="alpha" title="Sort A→Z">A↓</button>
                    </div>
                    <button class="var-pin-all-btn" id="var-pin-toggle" title="Pin/Unpin all">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L12 22M5 12l7-7 7 7"/></svg>
                    </button>
                </div>
            </div>
            <div id="var-entries-container"></div>`;
        body.innerHTML = html;

        // Attach control listeners
        const filterInput = body.querySelector('#var-filter');
        filterInput.addEventListener('input', (e) => {
            varFilterText = e.target.value;
            rebuildVarEntries();
        });

        body.querySelectorAll('.var-sort-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                varSortMode = btn.dataset.sort;
                body.querySelectorAll('.var-sort-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                rebuildVarEntries();
            });
        });

        body.querySelector('#var-pin-toggle').addEventListener('click', () => {
            const names = Object.keys(state.variables);
            if (state.pinnedVars.size > 0) {
                // Unpin all
                names.forEach(n => unpinVar(n));
            } else {
                // Pin all
                names.forEach(n => pinVar(n));
            }
            rebuildVarEntries();
        });

        rebuildVarEntries();
    }

    function rebuildVarEntries() {
        const container = $('#var-entries-container');
        if (!container) return;

        let names = Object.keys(state.variables);

        // Filter
        if (varFilterText) {
            const q = varFilterText.toLowerCase();
            names = names.filter(n => n.toLowerCase().includes(q) || (state.variables[n].desc || '').toLowerCase().includes(q));
        }

        // Sort
        if (varSortMode === 'alpha') {
            names.sort((a, b) => a.localeCompare(b));
        } else if (varSortMode === 'occurrence') {
            names.sort((a, b) => state.variables[a].firstIndex - state.variables[b].firstIndex);
        } else if (varSortMode === 'chapter') {
            names.sort((a, b) => state.variables[a].firstIndex - state.variables[b].firstIndex);
        }

        let html = '';
        let currentChapter = null;

        names.forEach(name => {
            const v = state.variables[name];
            const isPinned = state.pinnedVars.has(name);

            // Chapter group header
            if (varSortMode === 'chapter' && v.chapter !== currentChapter) {
                currentChapter = v.chapter;
                html += `<div class="var-chapter-header">${esc(currentChapter)}</div>`;
            }

            html += `
                <div class="var-entry ${isPinned ? 'pinned' : ''}" data-var="${esc(name)}">
                    <span class="var-name" style="color:${esc(v.color)}">
                        <span class="var-color-dot" style="background:${esc(v.color)}"></span>
                        ${esc(name)}
                    </span>
                    <span class="var-desc">${esc(v.desc)}</span>
                    <div class="var-nav" style="display:${isPinned ? 'flex' : 'none'}; margin-top: 4px;">
                        <button class="var-nav-btn def" title="Jump to definition"><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="18 15 12 9 6 15"/></svg></button>
                        <button class="var-nav-btn prev" title="Previous occurrence">&lt;</button>
                        <span class="var-nav-count">0/0</span>
                        <button class="var-nav-btn next" title="Next occurrence">&gt;</button>
                    </div>
                </div>`;
        });

        container.innerHTML = html;

        // Attach entry listeners
        container.querySelectorAll('.var-entry').forEach(entry => {
            entry.addEventListener('mouseenter', () => {
                if (!state.pinnedVars.has(entry.dataset.var)) highlightVar(entry.dataset.var);
            });
            entry.addEventListener('mouseleave', () => {
                if (!state.pinnedVars.has(entry.dataset.var)) unhighlightVar(entry.dataset.var);
            });

            entry.addEventListener('click', (e) => {
                if (e.target.closest('.var-nav-btn')) return;
                const name = entry.dataset.var;
                if (state.pinnedVars.has(name)) {
                    unpinVar(name);
                    entry.classList.remove('pinned');
                    entry.querySelector('.var-nav').style.display = 'none';
                } else {
                    pinVar(name);
                    entry.classList.add('pinned');
                    entry.querySelector('.var-nav').style.display = 'flex';
                    updateVarNav(entry, name);
                }
            });

            const defBtn = entry.querySelector('.var-nav-btn.def');
            const prevBtn = entry.querySelector('.var-nav-btn.prev');
            const nextBtn = entry.querySelector('.var-nav-btn.next');
            defBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigateVarToDefinition(entry, entry.dataset.var);
            });
            prevBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigateVar(entry, entry.dataset.var, -1);
            });
            nextBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                navigateVar(entry, entry.dataset.var, 1);
            });

            // Restore nav count for pinned vars
            if (state.pinnedVars.has(entry.dataset.var)) {
                updateVarNav(entry, entry.dataset.var);
            }
        });
    }

    function updateVarNav(entry, name) {
        const instances = Array.from(article.querySelectorAll(`.var[data-var="${CSS.escape(name)}"]`));
        const countSpan = entry.querySelector('.var-nav-count');

        let currentIndex = entry.dataset.currentNavIndex ? parseInt(entry.dataset.currentNavIndex) : -1;

        if (instances.length === 0) {
            countSpan.textContent = '0/0';
        } else {
            countSpan.textContent = `${currentIndex >= 0 ? currentIndex + 1 : 0}/${instances.length}`;
        }
    }

    function navigateVar(entry, name, direction) {
        const instances = Array.from(article.querySelectorAll(`.var[data-var="${CSS.escape(name)}"]`));
        if (instances.length === 0) return;

        let currentIndex = entry.dataset.currentNavIndex ? parseInt(entry.dataset.currentNavIndex) : -1;

        currentIndex += direction;
        if (currentIndex < 0) currentIndex = instances.length - 1;
        if (currentIndex >= instances.length) currentIndex = 0;

        entry.dataset.currentNavIndex = currentIndex;
        updateVarNav(entry, name);

        // Remove active class from old instances
        instances.forEach(ins => ins.classList.remove('active-nav-target'));

        // Highlight and scroll to new instance
        const target = instances[currentIndex];
        if (target) {
            target.classList.add('active-nav-target');
            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }

    function navigateVarToDefinition(entry, name) {
        const instances = Array.from(article.querySelectorAll(`.var[data-var="${CSS.escape(name)}"]`));
        if (instances.length === 0) return;

        // Jump to first occurrence (the definition)
        entry.dataset.currentNavIndex = 0;
        updateVarNav(entry, name);

        instances.forEach(ins => ins.classList.remove('active-nav-target'));
        instances[0].classList.add('active-nav-target');
        instances[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // ═══════════════════════════════════════════════
    //  References Panel (right)
    // ═══════════════════════════════════════════════

    function buildRefsPanel() {
        switchRefsPanel(state.references, null, state.docId);
    }

    function showRefDetail(num) {
        const ref = state.references[num];
        if (!ref) return;
        state.activeRef = num;
        $$('.ref-list-item').forEach(li => li.classList.toggle('active', li.dataset.ref === num));
        const userNote = state.userEdits.refNotes?.[num] || '';
        const noteHtml = userNote
            ? `<div class="ref-user-note"><div class="ref-user-note-label">Your Note</div>${esc(userNote)}</div>`
            : '';
        $('#ref-detail-view').innerHTML = `
            <div class="ref-detail">
                <div class="ref-detail-title">[${num}] ${esc(ref.title)}</div>
                ${ref.url ? `<a class="ref-detail-link" href="${esc(ref.url)}" target="_blank">${esc(ref.url)}</a>` : ''}
                ${ref.quote ? `<div class="ref-detail-quote">${esc(ref.quote)}</div>` : ''}
                ${noteHtml}
            </div>`;
    }

    // ═══════════════════════════════════════════════
    //  Variable Hover Highlighting
    // ═══════════════════════════════════════════════

    function setupVarHovers() {
        // Hover: temporary highlight (unless pinned)
        article.addEventListener('mouseover', (e) => {
            const v = e.target.closest('.var');
            if (v && !state.pinnedVars.has(v.dataset.var)) highlightVar(v.dataset.var);
        });
        article.addEventListener('mouseout', (e) => {
            const v = e.target.closest('.var');
            if (v && !state.pinnedVars.has(v.dataset.var)) unhighlightVar(v.dataset.var);
        });
        // Click: toggle pin
        article.addEventListener('click', (e) => {
            const v = e.target.closest('.var');
            if (!v) return;
            const name = v.dataset.var;

            const entry = $(`.var-entry[data-var="${CSS.escape(name)}"]`);

            if (state.pinnedVars.has(name)) {
                unpinVar(name);
                if (entry) entry.querySelector('.var-nav').style.display = 'none';
            } else {
                pinVar(name);
                if (entry) {
                    entry.querySelector('.var-nav').style.display = 'flex';
                    updateVarNav(entry, name);
                }
            }
        });

        // Right-Click: Edit description & notes
        article.addEventListener('contextmenu', (e) => {
            const v = e.target.closest('.var');
            if (!v) return;
            e.preventDefault();
            const name = v.dataset.var;
            showVarEditorPopup(name, e.clientX, e.clientY);
        });
    }

    function highlightVar(name) {
        article.querySelectorAll(`.var[data-var="${CSS.escape(name)}"]`).forEach(el => {
            el.classList.add('var-highlighted');
        });
        $$('.var-entry').forEach(entry => {
            if (entry.dataset.var === name) entry.classList.add('active');
        });
    }

    function unhighlightVar(name) {
        article.querySelectorAll(`.var-highlighted[data-var="${CSS.escape(name)}"]`).forEach(el => {
            el.classList.remove('var-highlighted');
        });
        $$('.var-entry.active').forEach(entry => {
            if (entry.dataset.var === name) entry.classList.remove('active');
        });
    }

    function pinVar(name) {
        state.pinnedVars.add(name);
        highlightVar(name);
        article.querySelectorAll(`.var[data-var="${CSS.escape(name)}"]`).forEach(el => {
            el.classList.add('var-pinned');
        });
    }

    function unpinVar(name) {
        state.pinnedVars.delete(name);
        article.querySelectorAll(`.var-pinned[data-var="${CSS.escape(name)}"]`).forEach(el => {
            el.classList.remove('var-pinned');
        });
        unhighlightVar(name);
    }

    // ═══════════════════════════════════════════════
    //  Variable Context Menu (Right-Click Edit)
    // ═══════════════════════════════════════════════

    function showVarEditorPopup(varName, x, y) {
        if ($('#annotation-popup')) $('#annotation-popup').remove();

        const v = state.variables[varName];
        if (!v) return;

        const popup = document.createElement('div');
        popup.id = 'annotation-popup';
        popup.className = 'annotation-popup var-edit-popup';
        popup.style.top = `${y + window.scrollY + 8}px`;
        popup.style.left = `${x}px`;

        popup.innerHTML = `
            <div style="font-size: 11px; font-weight: 600; text-transform: uppercase; color: var(--text-faint); margin-bottom: -4px;">Edit Variable: ${esc(varName)}</div>
            <textarea id="var-desc-edit" placeholder="Core Description...">${esc(v.desc || '')}</textarea>
            <textarea id="var-note-edit" placeholder="Personal Note (optional)..." style="height: 60px;">${esc(v.note || '')}</textarea>
            <div class="annotation-popup-actions" style="justify-content: flex-end;">
                <div class="row-actions">
                    <button class="btn-cancel" style="background:transparent; color:var(--text-secondary);">Cancel</button>
                    <button class="btn-save">Save</button>
                </div>
            </div>
        `;

        document.body.appendChild(popup);

        // Position adjustment
        const pRect = popup.getBoundingClientRect();
        if (pRect.right > window.innerWidth) {
            popup.style.left = `${window.innerWidth - pRect.width - 20}px`;
        }
        if (pRect.left < 0) {
            popup.style.left = `20px`;
        }

        // Close logic
        const closePopup = (ev) => {
            if (!popup.contains(ev.target)) {
                popup.remove();
                document.removeEventListener('click', closePopup);
            }
        };
        setTimeout(() => document.addEventListener('click', closePopup), 10);

        popup.querySelector('.btn-cancel').addEventListener('click', () => popup.remove());

        popup.querySelector('.btn-save').addEventListener('click', () => {
            const newDesc = popup.querySelector('#var-desc-edit').value.trim();
            const newNote = popup.querySelector('#var-note-edit').value.trim();

            v.desc = newDesc;
            v.note = newNote;

            // Re-render sidebar Variables panel to show updated desc
            buildVarsPanel();

            // Persist (assuming variables are saved in user context or metadata in the future)
            // For now, it lives in memory during the session until a backend route saves document metadata

            popup.remove();
            showToast('Variable updated');
        });
    }

    // ═══════════════════════════════════════════════
    //  TOC
    // ═══════════════════════════════════════════════

    function buildTOC() {
        const headings = article.querySelectorAll('h2, h3');
        tocMenu.innerHTML = '';
        headings.forEach((h, i) => {
            if (!h.id) h.id = `section-${i}`;
            const a = document.createElement('a');
            a.className = `toc-item ${h.tagName === 'H3' ? 'depth-3' : ''}`;
            a.textContent = h.textContent;
            a.href = `#${h.id}`;
            a.addEventListener('click', (e) => {
                e.preventDefault();
                h.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Keep TOC open — user closes manually or clicks outside
                a.classList.add('toc-item-active');
                tocMenu.querySelectorAll('.toc-item').forEach(item => {
                    if (item !== a) item.classList.remove('toc-item-active');
                });
            });
            tocMenu.appendChild(a);
        });
    }

    function setupTOCDropdown() {
        $('#toc-trigger').addEventListener('click', () => {
            $('#toc-dropdown').classList.toggle('open');
        });
        document.addEventListener('click', (e) => {
            // Only close if clicking outside the dropdown AND outside the trigger
            if (!$('#toc-dropdown').contains(e.target) && !$('#toc-trigger').contains(e.target)) {
                $('#toc-dropdown').classList.remove('open');
            }
        });
    }

    // ═══════════════════════════════════════════════
    //  Ref Badge Clicks
    // ═══════════════════════════════════════════════

    function setupRefBadgeClicks() {
        article.addEventListener('click', (e) => {
            const badge = e.target.closest('.ref-badge');
            if (badge) {
                panelRefs.classList.remove('collapsed');
                $('#refs-toggle').classList.add('active');
                // Always restore from the permanent main-article refs copy
                switchRefsPanel(state.mainReferences, badge.dataset.ref, state.docId);
                openRefInSplitView(badge.dataset.ref);
            }
        });
    }

    // ═══════════════════════════════════════════════
    //  Panel State Persistence (localStorage)
    // ═══════════════════════════════════════════════

    const STORAGE_KEY = 'scholarly-reader-panels';

    function savePanelState() {
        const state = {
            vars: !panelLeft.classList.contains('collapsed'),
            refs: !panelRefs.classList.contains('collapsed'),
            notes: !panelNotes.classList.contains('collapsed'),
            history: !$('#panel-history')?.classList.contains('collapsed'),
        };
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch { }
    }

    function loadPanelState() {
        try {
            const saved = JSON.parse(localStorage.getItem(STORAGE_KEY));
            if (saved) return saved;
        } catch { }
        return { vars: true, refs: false, notes: false, history: false }; // defaults
    }

    // ═══════════════════════════════════════════════
    //  Left Panel Toggle
    // ═══════════════════════════════════════════════

    function setupLeftPanel() {
        const saved = loadPanelState();
        if (!saved.vars) {
            panelLeft.classList.add('collapsed');
            $('#vars-toggle').classList.remove('active');
        }

        $('#vars-toggle').addEventListener('click', () => {
            const collapsed = panelLeft.classList.toggle('collapsed');
            $('#vars-toggle').classList.toggle('active', !collapsed);
            savePanelState();
        });
        $('#panel-left-close').addEventListener('click', () => {
            panelLeft.classList.add('collapsed');
            $('#vars-toggle').classList.remove('active');
            savePanelState();
        });
    }

    // ═══════════════════════════════════════════════
    //  Right Panel (Refs) Toggle
    // ═══════════════════════════════════════════════

    function setupRightPanel() {
        const saved = loadPanelState();

        // Restore refs state
        if (saved.refs) {
            panelRefs.classList.remove('collapsed');
            $('#refs-toggle').classList.add('active');
        } else {
            panelRefs.classList.add('collapsed');
        }

        // Restore notes state
        if (saved.notes) {
            panelNotes.classList.remove('collapsed');
            $('#notes-toggle').classList.add('active');
        } else {
            panelNotes.classList.add('collapsed');
        }

        // Restore history state
        const panelHistory = $('#panel-history');
        const historyToggle = $('#history-toggle');
        if (panelHistory && historyToggle) {
            if (saved.history) {
                panelHistory.classList.remove('collapsed');
                historyToggle.classList.add('active');
            } else {
                panelHistory.classList.add('collapsed');
            }
        }

        // Refs toggle
        $('#refs-toggle').addEventListener('click', () => {
            const collapsed = panelRefs.classList.toggle('collapsed');
            $('#refs-toggle').classList.toggle('active', !collapsed);
            savePanelState();
        });
        $('#panel-refs-close').addEventListener('click', () => {
            panelRefs.classList.add('collapsed');
            $('#refs-toggle').classList.remove('active');
            savePanelState();
        });

        // Notes toggle
        $('#notes-toggle').addEventListener('click', () => {
            const collapsed = panelNotes.classList.toggle('collapsed');
            $('#notes-toggle').classList.toggle('active', !collapsed);
            savePanelState();
        });
        $('#panel-notes-close').addEventListener('click', () => {
            panelNotes.classList.add('collapsed');
            $('#notes-toggle').classList.remove('active');
            savePanelState();
        });
    }

    // ═══════════════════════════════════════════════
    //  Resize Handle (refs panel)
    // ═══════════════════════════════════════════════

    function setupResizeHandle() {
        const handle = $('#resize-handle-refs');
        if (!handle) return;
        let startX, startWidth;

        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startX = e.clientX;
            startWidth = panelRefs.getBoundingClientRect().width;
            handle.classList.add('dragging');
            document.body.classList.add('resizing');

            const onMove = (e) => {
                requestAnimationFrame(() => {
                    const delta = startX - e.clientX;
                    const newWidth = Math.min(Math.max(startWidth + delta, 200), 700);
                    panelRefs.style.width = `${newWidth}px`;
                });
            };
            const onUp = () => {
                handle.classList.remove('dragging');
                document.body.classList.remove('resizing');
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });
    }

    // ═══════════════════════════════════════════════
    //  Selection Toolbar + Notes
    // ═══════════════════════════════════════════════

    function setupSelectionToolbar() {
        document.addEventListener('mouseup', (e) => {
            if (selToolbar.contains(e.target)) return;
            const sel = window.getSelection();
            const text = sel.toString().trim();
            if (text.length > 0 && article.contains(sel.anchorNode)) {
                const range = sel.getRangeAt(0);
                const rect = range.getBoundingClientRect();
                selToolbar.style.top = `${rect.top + window.scrollY - 44}px`;
                selToolbar.style.left = `${rect.left + rect.width / 2}px`;
                selToolbar.style.transform = 'translateX(-50%)';
                selToolbar.classList.add('visible');
            } else {
                selToolbar.classList.remove('visible');
            }
        });

        document.addEventListener('scroll', () => selToolbar.classList.remove('visible'), { passive: true });

        $('#sel-copy').addEventListener('click', () => {
            navigator.clipboard.writeText(window.getSelection().toString());
            selToolbar.classList.remove('visible');
            showToast('Copied to clipboard');
        });

        $('#sel-note').addEventListener('click', () => {
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const text = sel.toString().trim();
            if (text && article.contains(sel.anchorNode)) {
                state.pendingNoteText = text;
                state.pendingNoteRange = sel.getRangeAt(0).cloneRange();
                state.pendingNoteSource = 'human';
                panelNotes.classList.remove('collapsed');
                $('#notes-toggle').classList.add('active');
                showNoteEditor(text);
            }
            sel.removeAllRanges();
            selToolbar.classList.remove('visible');
        });

        // ── Highlight buttons ──
        $$('.sel-hl').forEach(btn => {
            btn.addEventListener('click', () => {
                const hlType = btn.dataset.hl;
                const sel = window.getSelection();
                if (!sel.rangeCount) return;
                const range = sel.getRangeAt(0);
                const text = sel.toString().trim();
                if (!text || !article.contains(range.commonAncestorContainer)) return;

                const mark = document.createElement('span');
                mark.className = 'user-hl';
                mark.dataset.hl = hlType;
                mark.dataset.hlId = Date.now().toString(36);
                const desc = `Highlight: ${hlType}`;
                try { range.surroundContents(mark); } catch { }
                pushHistory(desc);
                sel.removeAllRanges();
                selToolbar.classList.remove('visible');
                saveHighlights();
                showToast(`${hlType.charAt(0).toUpperCase() + hlType.slice(1)} applied`);
            });
        });

        // ── Collapse button ──
        $('#sel-collapse').addEventListener('click', async () => {
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const range = sel.getRangeAt(0).cloneRange();
            const text = sel.toString().trim();
            if (!text || text.length < 5 || !article.contains(range.commonAncestorContainer)) return;

            const defaultSummary = text.substring(0, 40).trim() + '…';
            const replacementText = window.prompt("Enter replacement text for this section:", defaultSummary);
            if (!replacementText) return; // User cancelled

            const anchor = buildAnchorFromRange(range);

            const wrapper = document.createElement('span');
            wrapper.className = 'collapsed-block';
            wrapper.dataset.collapseId = `tmp-${Date.now().toString(36)}`;

            const summaryEl = document.createElement('span');
            summaryEl.className = 'collapsed-summary';
            summaryEl.textContent = `📦 ${replacementText}`;
            summaryEl.title = text.substring(0, 200) + (text.length > 200 ? '…' : ''); // Hover tooltip
            summaryEl.addEventListener('click', () => wrapper.classList.add('expanded'));

            const fullEl = document.createElement('span');
            fullEl.className = 'collapsed-full';
            try {
                fullEl.appendChild(range.extractContents());
            } catch {
                fullEl.textContent = text;
            }

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'collapsed-toggle';
            toggleBtn.textContent = '▼ collapse';
            toggleBtn.addEventListener('click', () => wrapper.classList.remove('expanded'));
            fullEl.appendChild(toggleBtn);

            wrapper.appendChild(summaryEl);
            wrapper.appendChild(fullEl);
            range.insertNode(wrapper);

            pushHistory('Collapsed block: ' + replacementText);

            // Save to backend
            const ann = await fetchJSON(`/api/annotations/${state.docId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: 'collapse',
                    selectedText: text,
                    replacementText,
                    anchorSelector: anchor.selector,
                    anchorOffset: anchor.offset,
                }),
            });
            wrapper.dataset.collapseId = ann.id;
            state.annotations.push(ann);

            sel.removeAllRanges();
            selToolbar.classList.remove('visible');
            showToast('Text collapsed');
        });

        // ── Explain button (send to AI chat) ──
        const explainBtn = $('#sel-explain');
        if (explainBtn) {
            explainBtn.addEventListener('click', () => {
                const sel = window.getSelection();
                const text = sel.toString().trim();
                if (text && window.askAIAbout) {
                    window.askAIAbout(text);
                } else if (text) {
                    showToast('AI chat not available');
                }
                sel.removeAllRanges();
                selToolbar.classList.remove('visible');
            });
        }
    }

    function showNoteEditor(selectedText) {
        const notesList = $('#notes-list');
        const html = `
            <div class="note-editor" id="active-note-editor">
                <div class="note-editor-quote">"${esc(selectedText.substring(0, 200))}${selectedText.length > 200 ? '…' : ''}"</div>
                <div class="note-source-toggle">
                    <label><input type="radio" name="note-source" value="human" checked> Human Note</label>
                    <label><input type="radio" name="note-source" value="ai"> AI Note</label>
                </div>
                <textarea placeholder="Write your note…" autofocus></textarea>
                <div class="note-editor-actions">
                    <button class="note-cancel-btn" id="note-cancel">Cancel</button>
                    <button class="note-save-btn" id="note-save">Save</button>
                </div>
            </div>`;
        notesList.insertAdjacentHTML('afterbegin', html);
        const editor = $('#active-note-editor');
        editor.querySelector('textarea').focus();

        $('#note-cancel').addEventListener('click', () => {
            editor.remove();
            state.pendingNoteText = null;
            state.pendingNoteRange = null;
            state.pendingNoteSource = 'human';
        });
        $('#note-save').addEventListener('click', async () => {
            const note = editor.querySelector('textarea').value.trim();
            if (!note) return;
            const sourceInput = editor.querySelector('input[name="note-source"]:checked');
            const source = sourceInput ? sourceInput.value : 'human';
            const annType = source === 'ai' ? 'ai_note' : 'human_note';
            const anchor = state.pendingNoteRange ? buildAnchorFromRange(state.pendingNoteRange) : { selector: '', offset: 0 };

            // Wrap the text in the DOM immediately
            let mark = null;
            if (state.pendingNoteRange) {
                mark = document.createElement('span');
                mark.className = 'user-hl';
                mark.dataset.hl = annType === 'ai_note' ? 'ai-note' : 'note';
                mark.dataset.hlId = `tmp-${Date.now().toString(36)}`;
                try { state.pendingNoteRange.surroundContents(mark); } catch { }
            }

            pushHistory(source === 'ai' ? 'Added AI note' : 'Added note');

            // Save to backend
            const ann = await fetchJSON(`/api/annotations/${state.docId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: annType,
                    selectedText: state.pendingNoteText,
                    note,
                    color: 'note',
                    anchorSelector: anchor.selector,
                    anchorOffset: anchor.offset,
                }),
            });
            state.annotations.push(ann);
            if (mark) mark.dataset.hlId = ann.id;

            editor.remove();
            state.pendingNoteText = null;
            state.pendingNoteRange = null;
            state.pendingNoteSource = 'human';
            renderAnnotationsList();
            showToast('Note saved');
        });
    }

    function renderAnnotationsList() {
        const list = $('#notes-list');
        const editor = $('#active-note-editor');
        const notes = [...state.annotations]
            .filter(isNoteAnnotation)
            .sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0));

        if (notes.length === 0 && !editor) {
            list.innerHTML = '<p class="panel-empty">Select text to add a note.</p>';
            return;
        }

        let html = editor ? editor.outerHTML : '';
        notes.forEach(ann => {
            const date = ann.createdAt
                ? new Date(ann.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })
                : 'Unknown time';
            const source = getNoteSource(ann);
            const sourceLabel = source === 'ai' ? 'AI' : 'Human';
            const sourceCls = source === 'ai' ? 'ai' : 'human';
            const selectedText = ann.selectedText || '';
            const hasJump = !!(ann.anchorSelector || selectedText);
            html += `
                <div class="note-card">
                    ${selectedText ? `<div class="note-selected-text">"${esc(selectedText.substring(0, 120))}${selectedText.length > 120 ? '…' : ''}"</div>` : ''}
                    <div class="note-content">${esc(ann.note)}</div>
                    <div class="note-meta">
                        <span class="note-meta-left">
                            <span class="note-source-badge ${sourceCls}">${sourceLabel}</span>
                            <span>${date}</span>
                        </span>
                        <span class="note-meta-actions">
                            ${hasJump ? `<button class="note-jump" data-id="${ann.id}">Jump</button>` : ''}
                            <button class="note-delete" data-id="${ann.id}">Delete</button>
                        </span>
                    </div>
                </div>`;
        });
        list.innerHTML = html;

        list.querySelectorAll('.note-jump').forEach(btn => {
            btn.addEventListener('click', () => {
                const ann = state.annotations.find(a => a.id === btn.dataset.id);
                if (!ann) return;
                if (!jumpToAnnotationEvidence(ann)) {
                    showToast('Evidence anchor not found');
                }
            });
        });

        list.querySelectorAll('.note-delete').forEach(btn => {
            btn.addEventListener('click', async () => {
                await fetchJSON(`/api/annotations/${state.docId}/${btn.dataset.id}`, { method: 'DELETE' });
                const hl = article.querySelector(`.user-hl[data-hl-id="${escapeCss(btn.dataset.id)}"]`);
                if (hl && hl.parentNode) {
                    const parent = hl.parentNode;
                    while (hl.firstChild) parent.insertBefore(hl.firstChild, hl);
                    hl.remove();
                    parent.normalize();
                }
                state.annotations = state.annotations.filter(a => a.id !== btn.dataset.id);
                renderAnnotationsList();
                showToast('Note deleted');
            });
        });
    }

    // ═══════════════════════════════════════════════
    //  Utilities
    // ═══════════════════════════════════════════════

    function isNoteAnnotation(ann) {
        return ann && ['note', 'human_note', 'ai_note'].includes(ann.type);
    }

    function getNoteSource(ann) {
        if (!ann) return 'human';
        if (ann.type === 'ai_note') return 'ai';
        return 'human';
    }

    function getHighlightModeForAnnotation(ann) {
        if (ann.type === 'ai_note') return 'ai-note';
        if (ann.type === 'human_note' || ann.type === 'note') return 'note';
        return ann.color || ann.type || 'background';
    }

    function escapeCss(value) {
        if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') return CSS.escape(value);
        return String(value).replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
    }

    function buildCssPath(el) {
        if (!el || !article.contains(el)) return '';
        if (el.id) return `#${escapeCss(el.id)}`;
        const path = [];
        let current = el;
        while (current && current !== article) {
            let segment = current.tagName.toLowerCase();
            if (current.classList.contains('math-display')) segment += '.math-display';
            if (current.parentElement) {
                const siblings = Array.from(current.parentElement.children)
                    .filter(node => node.tagName === current.tagName);
                if (siblings.length > 1) {
                    segment += `:nth-of-type(${siblings.indexOf(current) + 1})`;
                }
            }
            path.unshift(segment);
            if (current.id) {
                path[0] = `#${escapeCss(current.id)}`;
                break;
            }
            current = current.parentElement;
        }
        return path.join(' > ');
    }

    function getAnchorContainer(startNode) {
        const startEl = startNode && startNode.nodeType === Node.TEXT_NODE ? startNode.parentElement : startNode;
        if (!startEl) return null;
        return startEl.closest('p, li, blockquote, h1, h2, h3, h4, h5, h6, pre, td, th, figcaption, .math-display')
            || startEl.closest('[id]')
            || startEl;
    }

    function getTextOffsetInContainer(container, range) {
        try {
            const offsetRange = document.createRange();
            offsetRange.selectNodeContents(container);
            offsetRange.setEnd(range.startContainer, range.startOffset);
            return offsetRange.toString().length;
        } catch {
            return 0;
        }
    }

    function buildAnchorFromRange(range) {
        if (!range) return { selector: '', offset: 0 };
        const container = getAnchorContainer(range.startContainer);
        if (!container) return { selector: '', offset: 0 };
        return {
            selector: buildCssPath(container),
            offset: getTextOffsetInContainer(container, range),
        };
    }

    function createRangeFromGlobalOffsets(nodes, start, end) {
        let startNode = null;
        let endNode = null;
        let startOffset = 0;
        let endOffset = 0;

        for (const entry of nodes) {
            if (!startNode && start >= entry.start && start <= entry.end) {
                startNode = entry.node;
                startOffset = start - entry.start;
            }
            if (!endNode && end >= entry.start && end <= entry.end) {
                endNode = entry.node;
                endOffset = end - entry.start;
            }
            if (startNode && endNode) break;
        }

        if (!startNode || !endNode) return null;
        const range = document.createRange();
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        return range;
    }

    function findRangeInContainer(container, selectedText, preferredOffset = null) {
        if (!container || !selectedText) return null;
        const target = selectedText.trim();
        if (!target) return null;

        const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
        const nodes = [];
        let fullText = '';
        while (walker.nextNode()) {
            const node = walker.currentNode;
            const start = fullText.length;
            fullText += node.textContent;
            nodes.push({ node, start, end: fullText.length });
        }
        if (!fullText) return null;

        const candidates = [];
        let idx = fullText.indexOf(target);
        while (idx !== -1) {
            candidates.push(idx);
            idx = fullText.indexOf(target, idx + 1);
        }
        if (candidates.length === 0) return null;

        let chosen = candidates[0];
        if (typeof preferredOffset === 'number' && !Number.isNaN(preferredOffset)) {
            chosen = candidates.reduce((best, curr) => (
                Math.abs(curr - preferredOffset) < Math.abs(best - preferredOffset) ? curr : best
            ), candidates[0]);
        }

        return createRangeFromGlobalOffsets(nodes, chosen, chosen + target.length);
    }

    function findRangeForAnnotation(ann) {
        if (!ann || !ann.selectedText) return null;
        const preferredOffset = Number.isFinite(Number(ann.anchorOffset)) ? Number(ann.anchorOffset) : null;

        if (ann.anchorSelector) {
            const container = article.querySelector(ann.anchorSelector) || document.querySelector(ann.anchorSelector);
            const anchoredRange = findRangeInContainer(container, ann.selectedText, preferredOffset);
            if (anchoredRange) return anchoredRange;
        }

        return findRangeInContainer(article, ann.selectedText, preferredOffset);
    }

    function jumpToAnnotationEvidence(ann) {
        const range = findRangeForAnnotation(ann);
        if (!range) return false;
        const targetEl = range.startContainer.nodeType === Node.TEXT_NODE
            ? range.startContainer.parentElement
            : range.startContainer;
        if (!targetEl) return false;
        targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        targetEl.classList.add('evidence-focus');
        setTimeout(() => targetEl.classList.remove('evidence-focus'), 1400);
        return true;
    }

    async function fetchJSON(url, opts = {}) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
    }

    function esc(str) {
        const d = document.createElement('div');
        d.textContent = str;
        return d.innerHTML;
    }

    // ═══════════════════════════════════════════════
    //  Unified Annotations System
    // ═══════════════════════════════════════════════

    // (Replaced localStorage with backend API for highlights and collapses)

    function setupAnnotations() {
        if (!state.annotations || !state.annotations.length) return;

        state.annotations.forEach(ann => {
            const range = findRangeForAnnotation(ann);
            if (!range) return;
            const anchorEl = range.startContainer.nodeType === Node.TEXT_NODE ? range.startContainer.parentElement : range.startContainer;
            if (anchorEl && anchorEl.closest('.user-hl, .collapsed-block')) return;

            if (ann.type === 'collapse') {
                const wrapper = document.createElement('span');
                wrapper.className = 'collapsed-block';
                wrapper.dataset.collapseId = ann.id;

                const summaryEl = document.createElement('span');
                summaryEl.className = 'collapsed-summary';
                summaryEl.textContent = `📦 ${ann.replacementText || ann.selectedText.substring(0, 40) + '…'}`;
                summaryEl.title = ann.selectedText.substring(0, 200) + (ann.selectedText.length > 200 ? '…' : '');
                summaryEl.addEventListener('click', () => wrapper.classList.add('expanded'));

                const fullEl = document.createElement('span');
                fullEl.className = 'collapsed-full';
                try {
                    fullEl.appendChild(range.extractContents());
                } catch {
                    fullEl.textContent = ann.selectedText;
                }

                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'collapsed-toggle';
                toggleBtn.textContent = '▼ collapse';
                toggleBtn.addEventListener('click', () => wrapper.classList.remove('expanded'));
                fullEl.appendChild(toggleBtn);

                wrapper.appendChild(summaryEl);
                wrapper.appendChild(fullEl);
                range.insertNode(wrapper);

            } else {
                const mark = document.createElement('span');
                mark.className = 'user-hl';
                mark.dataset.hl = getHighlightModeForAnnotation(ann);
                mark.dataset.hlId = ann.id;
                try { range.surroundContents(mark); } catch { }
            }
        });
    }

    // ═══════════════════════════════════════════════
    //  Edit Context Popup (Click-to-Edit annotations)
    // ═══════════════════════════════════════════════

    function setupAnnotationClick() {
        article.addEventListener('click', (e) => {
            if (document.body.classList.contains('eraser-mode')) return; // Eraser handles it

            const hl = e.target.closest('.user-hl');
            if (hl) {
                e.stopPropagation();
                showAnnotationEditorPopup(hl, e);
            }
        });
    }

    function showAnnotationEditorPopup(hlElement, e) {
        // Destroy existing popup if any
        if ($('#annotation-popup')) $('#annotation-popup').remove();

        const type = hlElement.dataset.hl;
        const hlId = hlElement.dataset.hlId;
        const rect = hlElement.getBoundingClientRect();

        let existingAnn = state.annotations.find(a => a.id === hlId);
        let noteText = existingAnn ? existingAnn.note : '';

        const popup = document.createElement('div');
        popup.id = 'annotation-popup';
        popup.className = 'annotation-popup';
        popup.style.top = `${rect.bottom + window.scrollY + 8}px`;
        popup.style.left = `${rect.left + (rect.width / 2)}px`;

        popup.innerHTML = `
            ${type !== 'highlight' ? `<textarea placeholder="Write a note...">${esc(noteText)}</textarea>` : ''}
            <div class="annotation-popup-actions">
                <div class="color-picker">
                    <button class="color-btn" style="background:#ffd70066" data-color="background"></button>
                    <button class="color-btn" style="background:#5ce6e666" data-color="note"></button>
                    <button class="color-btn" style="background:transparent;border:1px solid currentColor" data-color="border"></button>
                </div>
                <div class="row-actions">
                    <button class="btn-delete">Delete</button>
                    <button class="btn-save">Save</button>
                </div>
            </div>
        `;

        document.body.appendChild(popup);

        // Position adjustment
        const pRect = popup.getBoundingClientRect();
        if (pRect.right > window.innerWidth) {
            popup.style.left = `${window.innerWidth - pRect.width - 20}px`;
        }

        // Close on outside click
        const closePopup = (ev) => {
            if (!popup.contains(ev.target) && ev.target !== hlElement) {
                popup.remove();
                document.removeEventListener('click', closePopup);
            }
        };
        setTimeout(() => document.addEventListener('click', closePopup), 10);

        // Actions
        popup.querySelector('.btn-delete').addEventListener('click', async () => {
            // Delete from DOM
            const parent = hlElement.parentNode;
            while (hlElement.firstChild) parent.insertBefore(hlElement.firstChild, hlElement);
            hlElement.remove();
            parent.normalize();
            pushHistory('Deleted annotation');

            // Delete from backend if exists
            if (existingAnn) {
                await fetchJSON(`/api/annotations/${state.docId}/${existingAnn.id}`, { method: 'DELETE' });
                state.annotations = state.annotations.filter(a => a.id !== existingAnn.id);
                renderAnnotationsList();
            }
            popup.remove();
        });

        popup.querySelector('.btn-save').addEventListener('click', async () => {
            const ta = popup.querySelector('textarea');
            const newNote = ta ? ta.value.trim() : '';

            if (existingAnn) {
                existingAnn.note = newNote;
                await fetchJSON(`/api/annotations/${state.docId}/${existingAnn.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        note: existingAnn.note,
                        color: existingAnn.color,
                        replacementText: existingAnn.replacementText,
                        type: existingAnn.type,
                        selectedText: existingAnn.selectedText,
                        anchorSelector: existingAnn.anchorSelector,
                        anchorOffset: existingAnn.anchorOffset,
                    })
                });
            } else {
                // Convert pure DOM highlight to a fully backed annotation
                const range = document.createRange();
                range.selectNodeContents(hlElement);
                const anchor = buildAnchorFromRange(range);
                existingAnn = await fetchJSON(`/api/annotations/${state.docId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'highlight',
                        selectedText: hlElement.textContent || '',
                        note: newNote,
                        color: type,
                        anchorSelector: anchor.selector,
                        anchorOffset: anchor.offset,
                    })
                });
                state.annotations.push(existingAnn);
                hlElement.dataset.hlId = existingAnn.id;
            }

            if (existingAnn) {
                hlElement.dataset.hl = getHighlightModeForAnnotation(existingAnn);
            } else if (newNote && type !== 'note' && type !== 'ai-note') {
                hlElement.dataset.hl = 'note';
            }

            pushHistory(newNote ? 'Updated annotation note' : 'Updated annotation');

            renderAnnotationsList();
            popup.remove();
            showToast('Saved');
        });

        // Color picking
        popup.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const color = btn.dataset.color;
                hlElement.dataset.hl = color;
                if (existingAnn) existingAnn.color = color;
                pushHistory('Changed highlight color');
            });
        });
    }

    // ═══════════════════════════════════════════════
    //  Eraser Mode
    // ═══════════════════════════════════════════════

    function setupEraserMode() {
        const btn = $('#eraser-btn');
        btn.addEventListener('click', () => {
            const active = document.body.classList.toggle('eraser-mode');
            btn.classList.toggle('eraser-active', active);
            if (active) {
                showToast('Eraser mode ON — click highlights to remove');
            } else {
                showToast('Eraser mode OFF');
            }
        });

        // In eraser mode, clicking a highlight removes it
        article.addEventListener('click', (e) => {
            if (!document.body.classList.contains('eraser-mode')) return;
            const hl = e.target.closest('.user-hl');
            if (!hl) return;
            e.stopPropagation();

            // Unwrap
            const parent = hl.parentNode;
            while (hl.firstChild) parent.insertBefore(hl.firstChild, hl);
            hl.remove();
            parent.normalize();

            // Note: History pushes also need to push the current annotation state.
            // But since erase is DOM-first here, it's captured in pushHistory.
            pushHistory('Erased highlight');

            showToast('Highlight removed');
        });
    }

    // ═══════════════════════════════════════════════
    //  Tree-based Edit History (Undo / Redo)
    // ═══════════════════════════════════════════════

    function pushHistory(description) {
        const id = Date.now().toString(36);
        const html = article.innerHTML;
        // Deep clone current annotations for this history state
        const branchAnnotations = JSON.parse(JSON.stringify(state.annotations));

        const node = {
            id,
            parentId: state.historyTree.headId,
            childrenIds: [],
            html,
            annotations: branchAnnotations,
            description,
            timestamp: Date.now()
        };
        state.historyTree.nodes[id] = node;
        state.historyTree.nodes[state.historyTree.headId].childrenIds.push(id);
        state.historyTree.headId = id;
        renderHistoryTree();
        savePanelState(); // Save history panel state
    }

    function setupHistoryTree() {
        // Initialize root if empty
        if (!state.historyTree.nodes['root']) {
            state.historyTree.nodes['root'] = {
                id: 'root',
                parentId: null,
                childrenIds: [],
                html: article.innerHTML,
                annotations: JSON.parse(JSON.stringify(state.annotations)),
                description: 'Initial State',
                timestamp: Date.now()
            };
        }

        renderHistoryTree();

        // Keyboard shortcuts: ⌘Z / ⌘⇧Z
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                performTreeUndo();
            } else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                performTreeRedo();
            }
        });

        // Toggle panel UI
        const toggle = $('#history-toggle');
        const panel = $('#panel-history');
        const closeBtn = $('#panel-history-close');

        if (toggle && panel && closeBtn) {
            toggle.addEventListener('click', () => {
                panel.classList.toggle('collapsed');
                toggle.classList.toggle('active');
                savePanelState();
            });

            closeBtn.addEventListener('click', () => {
                panel.classList.add('collapsed');
                toggle.classList.remove('active');
                savePanelState();
            });
        }
    }

    function performTreeUndo() {
        const cur = state.historyTree.nodes[state.historyTree.headId];
        if (cur && cur.parentId) {
            checkoutHistoryNode(cur.parentId);
            showToast('Undone');
        }
    }

    function performTreeRedo() {
        const cur = state.historyTree.nodes[state.historyTree.headId];
        if (cur && cur.childrenIds.length > 0) {
            // Redo follows the most recently added child branch
            const lastChildId = cur.childrenIds[cur.childrenIds.length - 1];
            checkoutHistoryNode(lastChildId);
            showToast('Redone');
        }
    }

    async function checkoutHistoryNode(nodeId) {
        const node = state.historyTree.nodes[nodeId];
        if (!node) return;
        state.historyTree.headId = nodeId;
        article.innerHTML = node.html;

        // Sync the history node's annotations back to the active state and the backend
        if (node.annotations) {
            state.annotations = JSON.parse(JSON.stringify(node.annotations));
            await fetchJSON(`/api/annotations/${state.docId}/all`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ annotations: state.annotations })
            });
            renderAnnotationsList();
        }

        reattachDynamicListeners();
        renderHistoryTree();
    }

    function renderHistoryTree() {
        const container = $('#history-tree-container');
        if (!container) return;

        let html = '<div class="history-tree">';

        function renderNode(nodeId, depth) {
            const node = state.historyTree.nodes[nodeId];
            if (!node) return;

            const isHead = nodeId === state.historyTree.headId;
            const time = new Date(node.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            html += `
                <div class="history-node" style="margin-left: ${depth * 16}px" data-id="${nodeId}">
                    <div class="history-node-bullet ${isHead ? 'active' : ''}"></div>
                    <div class="history-node-content ${isHead ? 'active-text' : ''}">
                        <div class="history-desc">${esc(node.description)}</div>
                        <div class="history-time">${time}</div>
                    </div>
                </div>
            `;

            node.childrenIds.forEach(childId => {
                renderNode(childId, depth + 1);
            });
        }

        renderNode('root', 0);
        html += '</div>';
        container.innerHTML = html;

        // Attach checkout listeners
        container.querySelectorAll('.history-node').forEach(el => {
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                checkoutHistoryNode(el.dataset.id);
            });
        });
    }

    function reattachDynamicListeners() {
        // Re-attach collapse toggle listeners after innerHTML swap
        article.querySelectorAll('.collapsed-summary').forEach(el => {
            el.addEventListener('click', () => el.closest('.collapsed-block')?.classList.add('expanded'));
        });
        article.querySelectorAll('.collapsed-toggle').forEach(el => {
            el.addEventListener('click', () => el.closest('.collapsed-block')?.classList.remove('expanded'));
        });
        // Re-attach note popups, variable hovers etc. if needed
        setupVarHovers(); // Some instances might need rebinding
    }

    // ═══════════════════════════════════════════════
    //  Utilities
    // ═══════════════════════════════════════════════

    function showError(msg) {
        article.innerHTML = `
            <div style="text-align:center;padding:80px 20px;color:var(--text-dim);font-family:'Inter',sans-serif">
                <p style="font-size:48px;margin-bottom:16px">📄</p>
                <p style="font-size:16px;font-weight:600;margin-bottom:8px">No Document Loaded</p>
                <p style="font-size:14px">${esc(msg)}</p>
            </div>`;
    }

    function showToast(msg) {
        const t = document.createElement('div');
        t.textContent = msg;
        Object.assign(t.style, {
            position: 'fixed', bottom: '24px', left: '50%', transform: 'translateX(-50%)',
            background: 'var(--surface)', border: '1px solid var(--border)', color: 'var(--text)',
            padding: '8px 20px', borderRadius: '8px', fontFamily: "'Inter',sans-serif",
            fontSize: '13px', fontWeight: '500', zIndex: '400',
            boxShadow: '0 8px 32px rgba(0,0,0,0.4)',
        });
        document.body.appendChild(t);
        setTimeout(() => { t.style.opacity = '0'; t.style.transition = 'opacity 0.3s'; setTimeout(() => t.remove(), 300); }, 1800);
    }

    // Boot
    init().catch(err => { console.error('Init error:', err); showError(err.message); });
    // ═══════════════════════════════════════════════
    //  Split Views
    // ═══════════════════════════════════════════════

    // Shared split-view counter (used by both manual adds and ref-triggered splits)
    let splitCount = 0;
    let splitIsHorizontal = true;

    /**
     * Create a new split view showing a given HTML content.
     * @param {string} label     - Header label
     * @param {string} html      - Inner HTML for the split-content area
     * @param {string} [reuseId] - If a split with this id exists, reuse it instead of creating
     * @returns {HTMLElement} the split view element
     */
    function createSplitView(label, html, reuseId) {
        const container = $('#split-container');
        if (!container) return null;

        // Reuse existing split if requested
        if (reuseId) {
            const existing = $('#' + reuseId);
            if (existing) {
                if (label) existing.querySelector('.split-title').textContent = label;
                if (html) existing.querySelector('.split-content').innerHTML = html;
                existing.style.outline = '2px solid var(--accent, #7c6af7)';
                setTimeout(() => { existing.style.outline = ''; }, 800);
                return existing;
            }
        }

        splitCount++;
        const newId = reuseId || `split-${splitCount}`;

        const splitView = document.createElement('div');
        splitView.className = 'split-view';
        splitView.id = newId;

        splitView.innerHTML = `
            <div class="split-view-header" title="Drag to reorder">
                <span class="split-title">${label || `Split View ${splitCount}`}</span>
                <div class="split-view-actions">
                    <button class="btn-close-split" title="Close Split">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="split-content" id="article-${splitCount}">
                ${html || ''}
            </div>
        `;

        container.appendChild(splitView);

        splitView.querySelector('.btn-close-split').addEventListener('click', () => {
            splitView.remove();
        });

        const newArticle = splitView.querySelector('.split-content');
        newArticle.addEventListener('contextmenu', (e) => {
            const v = e.target.closest('.var');
            if (!v) return;
            e.preventDefault();
            showVarEditorPopup(v.dataset.var, e.clientX, e.clientY);
        });

        return splitView;
    }

    /**
     * Open a referenced paper in a split view (reusing the dedicated 'ref-split' slot).
     * Tries to match the reference title against locally available docs.
     * Falls back to a "not available" message with the ref metadata.
     */
    /** Open a ref by number, looking it up in state.references */
    async function openRefInSplitView(num) {
        const ref = state.references[num] || state.mainReferences[num];
        if (!ref) return;
        return openRefInSplitViewFromRef(ref, num);
    }

    /** Open a ref from a ref object directly (bypasses state.references lookup) */
    async function openRefInSplitViewFromRef(ref, num) {
        if (!ref) return;

        const label = `[${num}] ${ref.title}`;

        // Show a loading placeholder immediately
        const splitView = createSplitView(label,
            `<p class="panel-empty" style="padding:2rem;">⏳ Loading <em>${esc(ref.title)}</em>…</p>`,
            'ref-split');

        // Fetch doc list and try to match by title (case-insensitive substring)
        let matched = null;
        try {
            const docs = await fetchJSON('/api/docs');
            const refTitleLower = ref.title.toLowerCase();
            matched = docs.find(d => {
                const t = (d.title || d.id || '').toLowerCase();
                return t.includes(refTitleLower) || refTitleLower.includes(t);
            });
        } catch (e) { /* ignore */ }

        const contentEl = splitView.querySelector('.split-content');

        if (matched) {
            try {
                const docData = await fetchJSON(`/api/doc/${encodeURIComponent(matched.id)}`);
                contentEl.innerHTML = docData.content;
                postProcessSplitContent(contentEl);
            } catch (e) {
                contentEl.innerHTML = `<p class="panel-empty" style="padding:2rem;">⚠️ Failed to load <em>${esc(matched.title || matched.id)}</em>.</p>`;
            }
        } else {
            // Try to extract an arXiv ID from the reference URL or title
            const arxivId = ref.arxivId || extractArxivId(ref.url || '') || extractArxivId(ref.title || '');
            if (arxivId) {
                await importAndLoadInSplit(arxivId, ref.title, label, contentEl);
            } else {
                // No arXiv ID found — auto-search arXiv by title
                await searchAndImportInSplit(ref.title, num, label, contentEl);
            }
        }
    }

    /** Extract arXiv ID from a URL like https://arxiv.org/abs/1706.03762 or a bare "1706.03762" */
    function extractArxivId(str) {
        if (!str) return null;
        const m = str.match(/(?:arxiv\.org\/(?:abs|pdf)\/|arxiv:)?(\d{4}\.\d{4,5}(?:v\d+)?)/i);
        return m ? m[1] : null;
    }

    /** Search arXiv by title, pick the best match, then import automatically. */
    async function searchAndImportInSplit(title, num, label, contentEl) {
        contentEl.innerHTML = `
            <div style="padding:2rem;text-align:center;">
                <p>🔍 Searching arXiv for <strong>${esc(title)}</strong>…</p>
            </div>`;
        let arxivId = null;
        try {
            const data = await fetchJSON(`/api/arxiv-search?title=${encodeURIComponent(title)}`);
            if (data.results && data.results.length > 0) {
                arxivId = data.results[0].arxivId;
            }
        } catch (e) { /* ignore */ }

        if (arxivId) {
            await importAndLoadInSplit(arxivId, title, label, contentEl);
        } else {
            // Still nothing — show a small manual fallback
            contentEl.innerHTML = `
                <div class="ref-detail" style="padding:1.5rem;">
                    <div class="ref-detail-title">[${num}] ${esc(title)}</div>
                    <p class="panel-empty" style="margin-top:1rem;">
                        🔍 Couldn't find this paper on arXiv automatically.
                    </p>
                    <div style="margin-top:1rem;display:flex;gap:0.5rem;align-items:center;">
                        <input id="manual-arxiv-input" class="var-editor-input" placeholder="Enter arXiv ID manually (e.g. 1706.03762)" style="flex:1;padding:0.4rem 0.6rem;font-size:13px;" />
                        <button id="manual-arxiv-btn" class="ctx-item" style="padding:0.4rem 0.8rem;cursor:pointer;">Import</button>
                    </div>
                </div>`;
            contentEl.querySelector('#manual-arxiv-btn').addEventListener('click', async () => {
                const id = contentEl.querySelector('#manual-arxiv-input').value.trim();
                if (!id) return;
                await importAndLoadInSplit(id, title, label, contentEl);
            });
        }
    }

    /** Trigger arXiv import pipeline, poll for completion, then load into the split content area. */
    async function importAndLoadInSplit(arxivId, title, label, contentEl) {
        contentEl.innerHTML = `
            <div style="padding:2rem;text-align:center;">
                <p>⬇️ Downloading <strong>${esc(title || arxivId)}</strong>…</p>
                <p id="import-progress" style="color:var(--text-muted,#888);font-size:13px;margin-top:0.5rem;">Starting…</p>
            </div>`;

        let jobId;
        try {
            const res = await fetchJSON('/api/import-arxiv', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ arxivId, legacy: true })
            });
            jobId = res.jobId;
        } catch (e) {
            contentEl.innerHTML = `<p class="panel-empty" style="padding:2rem;">⚠️ Import failed: ${esc(e.message)}</p>`;
            return;
        }

        // Poll until done
        const progressEl = () => contentEl.querySelector('#import-progress');
        while (true) {
            await new Promise(r => setTimeout(r, 1500));
            let job;
            try { job = await fetchJSON(`/api/import-status/${jobId}`); } catch { break; }
            if (progressEl()) progressEl().textContent = job.progress || '…';
            if (job.status === 'done') {
                // Reload doc list and find the new doc
                try {
                    const docs = await fetchJSON('/api/docs');
                    const idLower = arxivId.replace('.', '-').toLowerCase();
                    const newDoc = docs.find(d => (d.id || '').toLowerCase().includes(idLower) || (d.id || '').includes(arxivId));
                    if (newDoc) {
                        const docData = await fetchJSON(`/api/doc/${encodeURIComponent(newDoc.id)}`);
                        contentEl.innerHTML = docData.content;
                        postProcessSplitContent(contentEl);
                    } else {
                        contentEl.innerHTML = `<p class="panel-empty" style="padding:2rem;">✅ Import complete — refresh the doc list to open it.</p>`;
                    }
                } catch (e) {
                    contentEl.innerHTML = `<p class="panel-empty" style="padding:2rem;">✅ Import done but couldn't load: ${esc(e.message)}</p>`;
                }
                break;
            } else if (job.status === 'error') {
                contentEl.innerHTML = `<p class="panel-empty" style="padding:2rem;">⚠️ Import error: ${esc(job.error || 'unknown')}</p>`;
                break;
            }
        }
    }

    /**
     * Post-process a newly loaded split content element:
     * 1. Render <span class="math-raw"> via KaTeX
     * 2. Build ref map from bibliography <li id="ref-N">
     * 3. Convert [N] or [citationKey] plain text to clickable ref-badge spans
     * 4. Wire ref-badge clicks to showRefDetail
     */
    function postProcessSplitContent(el) {
        // --- 1. Render math-raw spans via KaTeX ---
        if (window.katex) {
            el.querySelectorAll('.math-raw').forEach(span => {
                const raw = span.textContent || '';
                const isDisplay = span.closest('.math-display') !== null;
                try {
                    const rendered = katex.renderToString(raw, {
                        displayMode: isDisplay,
                        throwOnError: false,
                        trust: true,
                    });
                    const wrapper = document.createElement(isDisplay ? 'span' : 'span');
                    wrapper.className = isDisplay ? 'katex-display' : 'katex-inline';
                    wrapper.innerHTML = rendered;
                    span.replaceWith(wrapper);
                } catch (e) { /* leave as-is */ }
            });
        }

        // --- 2. Build ref map from <li id="ref-N"> or <li id="ref-key"> ---
        const refMap = {}; // key/num -> { title, url, arxivId }
        el.querySelectorAll('li[id^="ref-"]').forEach((li, idx) => {
            const rawKey = li.id.replace('ref-', '');
            const num = String(idx + 1);
            const arxivMatch = (li.textContent || '').match(/arxiv[:/]+(\d{4}\.\d{4,5}(?:v\d+)?)/i);
            const linkMatch = (li.innerHTML || '').match(/href="([^"]+)"/i);
            // Extract title: first <em> or second text chunk
            const titleEl = li.querySelector('em') || li.querySelector('strong');
            const title = titleEl
                ? titleEl.textContent.trim()
                : (li.textContent.split('.')[1] || '').trim() || `Reference ${rawKey}`;
            const entry = {
                title,
                url: linkMatch ? linkMatch[1] : '',
                arxivId: arxivMatch ? arxivMatch[1].split('v')[0] : '',
                num,
            };
            refMap[rawKey] = entry; // key-based lookup
            refMap[num] = entry;    // numeric lookup
            // Update li id to numeric for consistency
            li.id = `ref-${num}`;
        });

        if (Object.keys(refMap).length === 0) return;

        // --- 3. Walk text nodes and replace [key] or [N] with ref-badge spans ---
        // Matches: [1], [ba2016layer], [1, 2], [key1, key2]
        const citeTest = /\[[\w:.,\s-]{1,200}\]/; // non-global for acceptNode

        const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
            acceptNode(node) {
                const parent = node.parentElement;
                if (!parent) return NodeFilter.FILTER_REJECT;
                const tag = parent.tagName;
                if (['SCRIPT','STYLE','SUP','MATH','CODE','PRE'].includes(tag)) return NodeFilter.FILTER_REJECT;
                if (parent.classList.contains('ref-badge')) return NodeFilter.FILTER_REJECT;
                if (parent.closest('.katex,.math-inline,.math-display,.katex-display')) return NodeFilter.FILTER_REJECT;
                return citeTest.test(node.textContent) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            }
        });

        const nodes = [];
        let n;
        while ((n = walker.nextNode())) nodes.push(n);

        nodes.forEach(node => {
            const frag = document.createDocumentFragment();
            let last = 0;
            let m;
            const citePat = /(\[[\w:.,\s-]{1,200}\])/g; // fresh global per node
            const text = node.textContent;
            while ((m = citePat.exec(text)) !== null) {
                if (m.index > last) frag.appendChild(document.createTextNode(text.slice(last, m.index)));
                last = m.index + m[0].length;

                // Parse keys inside brackets
                const inner = m[1].slice(1, -1); // strip [ ]
                const keys = inner.split(/[,\s]+/).map(k => k.trim()).filter(Boolean);
                const matchedKeys = keys.filter(k => refMap[k]);

                if (matchedKeys.length === 0) {
                    frag.appendChild(document.createTextNode(m[1]));
                    continue;
                }

                matchedKeys.forEach((key, i) => {
                    const ref = refMap[key];
                    const sup = document.createElement('sup');
                    sup.className = 'ref-badge';
                    sup.dataset.ref = ref.num;
                    sup.dataset.title = ref.title;
                    if (ref.url) sup.dataset.url = ref.url;
                    if (ref.arxivId) sup.dataset.arxivId = ref.arxivId;
                    sup.textContent = ref.num;
                    sup.style.cursor = 'pointer';
                    sup.style.color = 'var(--accent, #7c6af7)';
                    frag.appendChild(sup);
                    if (i < matchedKeys.length - 1) frag.appendChild(document.createTextNode('​'));
                });
            }
            if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
            node.parentNode.replaceChild(frag, node);
        });

        // --- 4. Wire clicks on existing + newly created ref-badges ---
        // Build a complete refsMap from this split content for panel switching
        const splitRefsMap = extractRefsFromEl(el);

        el.querySelectorAll('.ref-badge[data-ref]').forEach(badge => {
            badge.addEventListener('click', () => {
                const num = badge.dataset.ref;
                const panelTitle = el.closest('.split-view')?.querySelector('.split-title')?.textContent || '';
                switchRefsPanel(splitRefsMap, num, panelTitle);
                openRefInSplitViewFromRef(splitRefsMap[num], num);
            });
        });
    }

    /**
     * Chrome-style tab drag-to-reorder via pointer events (more reliable than HTML5 drag API).
     * - Dragging the header shows a floating ghost clone following the cursor
     * - A slim insertion-line placeholder tracks the drop position between panels
     * - Release drops the panel into the indicated position
     */
    function setupSplitDragReorder() {
        const container = $('#split-container');
        if (!container) return;

        let dragSrc = null;
        let ghost = null;
        let indicator = null;
        let startX = 0, startY = 0;
        let dragging = false;

        function getInsertTarget(clientX) {
            const splits = [...container.querySelectorAll('.split-view:not(.drag-indicator)')];
            for (const sv of splits) {
                if (sv === dragSrc) continue;
                const rect = sv.getBoundingClientRect();
                if (clientX < rect.left + rect.width / 2) return { before: sv };
            }
            return { before: null }; // append at end
        }

        container.addEventListener('pointerdown', e => {
            const header = e.target.closest('.split-view-header');
            if (!header) return;
            // Don't drag if clicking the close button
            if (e.target.closest('.btn-close-split')) return;
            dragSrc = header.closest('.split-view');
            startX = e.clientX;
            startY = e.clientY;
            dragging = false;
            container.setPointerCapture(e.pointerId);
            e.preventDefault();
        });

        container.addEventListener('pointermove', e => {
            if (!dragSrc) return;
            const dx = e.clientX - startX, dy = e.clientY - startY;

            if (!dragging && Math.sqrt(dx*dx + dy*dy) < 6) return;

            if (!dragging) {
                dragging = true;
                // Create ghost
                ghost = dragSrc.cloneNode(true);
                ghost.style.cssText = `
                    position:fixed;pointer-events:none;z-index:9999;
                    width:${dragSrc.offsetWidth}px;height:${dragSrc.offsetHeight}px;
                    opacity:0.85;box-shadow:0 8px 32px rgba(0,0,0,0.45);
                    border-radius:6px;top:${dragSrc.getBoundingClientRect().top}px;
                    left:${dragSrc.getBoundingClientRect().left}px;
                    transition:none;background:var(--surface-1,#1e1e2e);will-change:transform;
                `;
                document.body.appendChild(ghost);
                dragSrc.style.opacity = '0.3';

                // Create thin insertion indicator
                indicator = document.createElement('div');
                indicator.className = 'drag-indicator';
                indicator.style.cssText = `
                    width:3px;min-width:3px;align-self:stretch;flex-shrink:0;
                    background:var(--accent,#7c6af7);border-radius:3px;
                    margin:4px 0;pointer-events:none;
                    box-shadow:0 0 8px var(--accent,#7c6af7);
                `;
                container.appendChild(indicator);
            }

            // Move ghost using transform for smooth 60fps updates
            requestAnimationFrame(() => {
                if (!ghost) return;
                ghost.style.transform = `translate(${e.clientX - startX}px, ${e.clientY - startY}px)`;
            });

            // Update indicator position
            const { before } = getInsertTarget(e.clientX);
            if (before) container.insertBefore(indicator, before);
            else container.appendChild(indicator);
        });

        container.addEventListener('pointerup', e => {
            if (!dragSrc) return;
            if (dragging && indicator) {
                container.insertBefore(dragSrc, indicator);
                indicator.remove();
                ghost.remove();
                dragSrc.style.opacity = '';
            }
            dragSrc = null; ghost = null; indicator = null; dragging = false;
        });

        container.addEventListener('pointercancel', () => {
            if (ghost) ghost.remove();
            if (indicator) indicator.remove();
            if (dragSrc) dragSrc.style.opacity = '';
            dragSrc = null; ghost = null; indicator = null; dragging = false;
        });
    }

    function setupSplitViews() {
        const btnAdd = $('#btn-add-split');
        const btnOrientation = $('#btn-split-orientation');
        const container = $('#split-container');
        if (!btnAdd || !container) return;

        // Orientation toggle
        if (btnOrientation) {
            btnOrientation.addEventListener('click', () => {
                splitIsHorizontal = !splitIsHorizontal;
                container.classList.toggle('split-vertical', !splitIsHorizontal);
                const svg = btnOrientation.querySelector('svg');
                if (svg) svg.style.transform = splitIsHorizontal ? '' : 'rotate(90deg)';
            });
        }

        btnAdd.addEventListener('click', () => {
            createSplitView(`Split View ${splitCount + 1}`, $('#article').innerHTML);
        });
    }

    // ─── Annotation Minimap ──────────────────────────────────
    function buildAnnotationMinimap() {
        const minimap = $('#annotation-minimap');
        if (!minimap) return;

        const article = $('#article');
        if (!article) return;

        const articleHeight = article.scrollHeight;
        const viewportHeight = article.clientHeight;
        if (!articleHeight || articleHeight <= 0) return;

        minimap.innerHTML = '';

        // Collect annotated elements
        const markers = [];

        // Highlights
        article.querySelectorAll('.user-highlight').forEach(el => {
            const color = el.style.backgroundColor || '#f0a050';
            markers.push({ el, color, type: 'highlight' });
        });

        // Collapses
        article.querySelectorAll('.collapse-marker').forEach(el => {
            markers.push({ el, color: '#d2a8ff', type: 'collapse' });
        });

        // Pinned variables
        article.querySelectorAll('.var.pinned').forEach(el => {
            const varColor = getComputedStyle(el).getPropertyValue('--var-color').trim() || '#f0a050';
            markers.push({ el, color: varColor, type: 'var-pin' });
        });

        // Render dots
        markers.forEach(({ el, color, type }) => {
            const rect = el.getBoundingClientRect();
            const articleRect = article.getBoundingClientRect();
            const relativeTop = (rect.top - articleRect.top + article.scrollTop) / articleHeight;

            if (relativeTop < 0 || relativeTop > 1) return;

            const dot = document.createElement('div');
            dot.className = 'minimap-dot';
            dot.style.top = `${relativeTop * 100}%`;
            dot.style.backgroundColor = color;
            dot.title = type === 'highlight' ? 'Highlight' :
                type === 'collapse' ? 'Collapsed text' :
                    type === 'var-pin' ? 'Pinned variable' : 'Annotation';

            dot.addEventListener('click', () => {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });

            minimap.appendChild(dot);
        });

        // Add viewport indicator
        const scrollRatio = article.scrollTop / articleHeight;
        const viewRatio = viewportHeight / articleHeight;

        const viewIndicator = document.createElement('div');
        viewIndicator.className = 'minimap-viewport';
        viewIndicator.style.top = `${scrollRatio * 100}%`;
        viewIndicator.style.height = `${Math.max(viewRatio * 100, 3)}%`;
        minimap.appendChild(viewIndicator);
    }

    // Wire minimap to scroll and changes
    if (article) {
        article.addEventListener('scroll', () => {
            requestAnimationFrame(buildAnnotationMinimap);
        });
        // Rebuild minimap when DOM changes (annotations added/removed)
        const observer = new MutationObserver(() => {
            requestAnimationFrame(buildAnnotationMinimap);
        });
        observer.observe(article, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] });
    }

    // Initial build after a delay (document needs to load first)
    setTimeout(buildAnnotationMinimap, 2000);

    // ─── Panel Tab Switcher ─────────────────────────────────
    (function setupPanelTabs() {
        const tabs = $$('.panel-tab');
        const contents = $$('.panel-tab-content');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const target = tab.dataset.tab;
                tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === target));
                contents.forEach(c => c.classList.toggle('active', c.dataset.tab === target));
            });
        });
    })();

    // ─── Equation Panel ─────────────────────────────────────
    let activeEqIndex = -1;

    function buildEquationPanel() {
        const eqBody = $('#equations-body');
        if (!eqBody) return;

        const mathDisplays = article.querySelectorAll('.math-display');
        if (mathDisplays.length === 0) {
            eqBody.innerHTML = '<p class="panel-empty">No equations found.</p>';
            return;
        }

        eqBody.innerHTML = '';

        mathDisplays.forEach((mathEl, index) => {
            // Assign an ID for scrolling
            if (!mathEl.id) mathEl.id = `eq-${index}`;

            // Extract text preview (clean up whitespace)
            let preview = mathEl.textContent.replace(/\s+/g, ' ').trim();
            if (preview.length > 60) preview = preview.substring(0, 60) + '…';

            // Extract variables used in this equation
            const vars = new Set();
            mathEl.querySelectorAll('.var[data-var]').forEach(v => vars.add(v.dataset.var));

            // Also check inline math in the surrounding context (the parent section)
            // But primarily we want the variables IN this equation
            const varList = [...vars];

            // Build the equation item
            const item = document.createElement('div');
            item.className = 'eq-item';
            item.dataset.eqIndex = index;

            let html = `<div class="eq-label">Equation ${index + 1}</div>`;
            html += `<div class="eq-preview">${escapeHtml(preview)}</div>`;

            if (varList.length > 0) {
                html += '<div class="eq-vars">';
                varList.forEach(v => {
                    html += `<span class="eq-var-chip">${escapeHtml(v)}</span>`;
                });
                html += '</div>';
            }

            item.innerHTML = html;

            // Click handler: jump to equation + cross-highlight variables
            item.addEventListener('click', () => {
                const isAlreadyActive = item.classList.contains('active');

                // Clear all active states
                eqBody.querySelectorAll('.eq-item.active').forEach(el => el.classList.remove('active'));
                clearEquationHighlighting();

                if (isAlreadyActive) {
                    activeEqIndex = -1;
                    return;
                }

                // Activate this equation
                item.classList.add('active');
                activeEqIndex = index;

                // Scroll to equation in article
                mathEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Flash effect on the equation
                mathEl.style.transition = 'box-shadow 0.3s';
                mathEl.style.boxShadow = '0 0 0 3px var(--accent)';
                setTimeout(() => { mathEl.style.boxShadow = ''; }, 1500);

                // Cross-highlight variables in the var panel
                highlightEquationVars(varList);
            });

            eqBody.appendChild(item);
        });
    }

    function highlightEquationVars(varNames) {
        const varEntries = $$('.var-entry');
        if (varEntries.length === 0) return;

        const nameSet = new Set(varNames);

        varEntries.forEach(entry => {
            const entryVar = entry.dataset.var;
            if (nameSet.has(entryVar)) {
                entry.classList.add('eq-focused');
                entry.classList.remove('eq-dimmed');
            } else {
                entry.classList.remove('eq-focused');
                entry.classList.add('eq-dimmed');
            }
        });
    }

    function clearEquationHighlighting() {
        $$('.var-entry').forEach(entry => {
            entry.classList.remove('eq-focused', 'eq-dimmed');
        });
    }

    function escapeHtml(str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Build equation panel after document loads
    setTimeout(buildEquationPanel, 1500);

    // ─── AI Chat Widget ─────────────────────────────────────

    (function setupChat() {
        const widget = $('#chat-widget');
        const toggle = $('#chat-toggle');
        const closeBtn = $('#chat-close');
        const input = $('#chat-input');
        const sendBtn = $('#chat-send');
        const messages = $('#chat-messages');
        if (!widget || !toggle) return;

        toggle.addEventListener('click', () => widget.classList.add('open'));
        if (closeBtn) closeBtn.addEventListener('click', () => widget.classList.remove('open'));

        async function sendMessage(text, context) {
            if (!text.trim()) return;

            // Add user message
            const userMsg = document.createElement('div');
            userMsg.className = 'chat-msg user';
            userMsg.textContent = text;
            messages.appendChild(userMsg);
            if (input) input.value = '';

            // Add assistant placeholder
            const assistantMsg = document.createElement('div');
            assistantMsg.className = 'chat-msg assistant';
            assistantMsg.textContent = '...';
            messages.appendChild(assistantMsg);
            messages.scrollTop = messages.scrollHeight;

            try {
                const res = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question: text, context: context || '', docId: currentDoc }),
                });

                if (!res.ok) {
                    const err = await res.json();
                    assistantMsg.textContent = `⚠️ ${err.error || 'Error'}`;
                    return;
                }

                // Read SSE stream
                assistantMsg.textContent = '';
                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });

                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                if (data.content) {
                                    assistantMsg.textContent += data.content;
                                    messages.scrollTop = messages.scrollHeight;
                                }
                                if (data.error) {
                                    assistantMsg.textContent += `\n⚠️ ${data.error}`;
                                }
                            } catch { }
                        }
                    }
                }
            } catch (err) {
                assistantMsg.textContent = `⚠️ ${err.message}`;
            }
        }

        if (sendBtn) sendBtn.addEventListener('click', () => sendMessage(input.value));
        if (input) input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(input.value);
            }
        });

        // Expose for "Explain this" from selection toolbar
        window.askAIAbout = function (text) {
            widget.classList.add('open');
            sendMessage(`Explain this passage:\n\n"${text}"`, text);
        };
    })();

    // ─── ArXiv Import Modal ─────────────────────────────────
    (function setupImport() {
        const overlay = $('#import-overlay');
        const inputEl = $('#import-input');
        const submitBtn = $('#import-submit');
        const cancelBtn = $('#import-cancel');
        const progressEl = $('#import-progress');
        const progressText = $('#import-progress-text');
        if (!overlay) return;

        // Open import modal from doc picker
        // We dynamically add an "Import from arXiv" button to the doc picker menu
        const pickerMenu = $('#doc-picker-menu');
        if (pickerMenu) {
            const origBuildMenu = window._buildDocMenuFn;
            // Observe doc picker menu for when it gets populated
            const observer = new MutationObserver(() => {
                if (pickerMenu.children.length > 0 && !pickerMenu.querySelector('.import-trigger')) {
                    const sep = document.createElement('div');
                    sep.style.cssText = 'border-top:1px solid var(--border);margin:4px 0;';
                    pickerMenu.appendChild(sep);

                    const btn = document.createElement('button');
                    btn.className = 'doc-item import-trigger';
                    btn.innerHTML = '📥 Import from arXiv';
                    btn.style.cssText = 'width:100%;text-align:left;padding:8px 12px;background:none;border:none;color:var(--accent);cursor:pointer;font-size:13px;';
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        overlay.style.display = 'flex';
                        if (inputEl) inputEl.focus();
                    });
                    pickerMenu.appendChild(btn);
                }
            });
            observer.observe(pickerMenu, { childList: true });
        }

        if (cancelBtn) cancelBtn.addEventListener('click', () => {
            overlay.style.display = 'none';
            if (progressEl) progressEl.style.display = 'none';
        });

        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.style.display = 'none';
                if (progressEl) progressEl.style.display = 'none';
            }
        });

        if (submitBtn) submitBtn.addEventListener('click', async () => {
            const arxivId = inputEl.value.trim();
            if (!arxivId) return;

            submitBtn.disabled = true;
            if (progressEl) progressEl.style.display = 'flex';
            if (progressText) progressText.textContent = 'Starting import...';

            try {
                const res = await fetch('/api/import-arxiv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ arxivId }),
                });
                const { jobId } = await res.json();

                // Poll for completion
                const poll = setInterval(async () => {
                    try {
                        const statusRes = await fetch(`/api/import-status/${jobId}`);
                        const job = await statusRes.json();

                        if (progressText) progressText.textContent = job.progress || job.status;

                        if (job.status === 'done') {
                            clearInterval(poll);
                            overlay.style.display = 'none';
                            if (progressEl) progressEl.style.display = 'none';
                            submitBtn.disabled = false;
                            // Load the new document
                            if (job.result && job.result.filename) {
                                window.location.href = `/?doc=${encodeURIComponent(job.result.filename)}`;
                            }
                        } else if (job.status === 'error') {
                            clearInterval(poll);
                            if (progressText) progressText.textContent = `❌ ${job.error}`;
                            submitBtn.disabled = false;
                        }
                    } catch { }
                }, 1500);
            } catch (err) {
                if (progressText) progressText.textContent = `❌ ${err.message}`;
                submitBtn.disabled = false;
            }
        });

        if (inputEl) inputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitBtn.click();
            }
        });
    })();

})();
